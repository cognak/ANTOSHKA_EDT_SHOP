////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность".
// Клиентские и серверные процедуры и функции общего назначения:
// - для поддержки формирования печатных форм;
// - для работы с файлами;
// - для работы с управляемыми формами; 
// - для работы с почтовыми адресами;
// - для работы с отборами динамических списков;
// - прочее.
//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//  Параметры
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                - Любая ссылка на объект информационной базы.
//                               Ссылка на объект информационной базы, к которому это сообщение относится,
//                               или ключ записи.
//  Поле                       - Строка - наименование реквизита формы
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы)
//  Отказ                      - Булево - Выходной параметр
//                               Всегда устанавливается в значение Истина
//
//	Примеры использования:
//
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения связанного с объектом информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
// 4. Для вывода сообщения по ссылке на объект информационной базы
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
// Случаи некорректного использования:
//  1. Передача одновременно параметров КлючДанных и ПутьКДанным
//  2. Передача в параметре КлючДанных значения типа отличного от допустимых
//  3. Установка ссылки без установки поля (и/или пути к данным)
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ (ТонкийКлиент ИЛИ ВебКлиент) Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = Найти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Попытка
			Сообщение.КлючДанных = КлючДанных;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Добавляет в список ошибок новую ошибку пользователя для дальнейшей отправки
// с помощью процедуры СообщитьОшибкиПользователю().
//  Используется в процедурах ОбработкаПроверкиЗаполнения.
//
// Параметры:
//  Ошибки          - Неопределено - будет создан новый список,
//                  - значение, установленное при первом вызове этой процедуры со значением Неопределено.
//
//  ПолеОшибки      - Строка - значение, которое задается в свойстве Поле объекта СообщениеПользователю.
//                    Для автоподстаноски номера строки должна содержать "%1".
//                    Например, "Объект.ИНН" или "Объект.Пользователи[%1].Пользователь".
//
//  ТекстДляОднойОшибки - Строка - текст ошибки для случая, когда ГруппаОшибок в коллекции только одна,
//                    например, НСтр("ru = 'Пользователь не выбран.'").
//
//  ГруппаОшибок    - Произвольный - используется для выбора либо текста для одной ошибки,
//                    либо текста для нескольких ошибок, например, имя "Объект.Пользователи".
//                    Если значение не заполнено, тогда используется текст для одной ошибки.
//
//  НомерСтроки     - Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки и в ТекстДляНесколькихОшибок (подставляется НомерСтроки + 1).
//
//  ТекстДляНесколькихОшибок - Строка - текст ошибки для случая, когда добавлено несколько ошибок с одинаковым
//                    свойством ГруппаОшибок, например, НСтр("ru = 'Пользователь в строке %1 не выбран.'").
//
Процедура ДобавитьОшибкуПользователю(Ошибки, Знач ПолеОшибки, Знач ТекстДляОднойОшибки, Знач ГруппаОшибок = "", Знач НомерСтроки = 0, Знач ТекстДляНесколькихОшибок = "") Экспорт
	
	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Структура;
		Ошибки.Вставить("СписокОшибок", Новый Массив);
		Ошибки.Вставить("ГруппыОшибок", Новый Соответствие);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ГруппаОшибок) Тогда
		// При незаполненной группе ошибок используется текст для одной ошибки.
	Иначе
		Если Ошибки.ГруппыОшибок[ГруппаОшибок] = Неопределено Тогда
			// Группа ошибок использовалась один раз, используется текст для одной ошибки.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Ложь);
		Иначе
			// Группа ошибок использовалась несколько раз, используется текст для нескольких ошибок.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Истина);
		КонецЕсли;
	КонецЕсли;
	
	Ошибка = Новый Структура;
	Ошибка.Вставить("ПолеОшибки",               ПолеОшибки);
	Ошибка.Вставить("ТекстДляОднойОшибки",      ТекстДляОднойОшибки);
	Ошибка.Вставить("ГруппаОшибок",             ГруппаОшибок);
	Ошибка.Вставить("НомерСтроки",              НомерСтроки);
	Ошибка.Вставить("ТекстДляНесколькихОшибок", ТекстДляНесколькихОшибок);
	
	Ошибки.СписокОшибок.Добавить(Ошибка);
	
КонецПроцедуры

// Сообщает ошибки добавленные с помощью процедуры ДобавитьОшибкуПользователю().
//
// Параметры:
//  Ошибки  - Неопределено - возврат,
//            значение, установленное при использовании процедуры ДобавитьОшибкуПользователю().
//  Отказ   - Булево, устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Знач Ошибки, Отказ = Ложь) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Возврат;
	Иначе
		Отказ = Истина;
	КонецЕсли;
	
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			
			СообщитьПользователю(
				Ошибка.ТекстДляОднойОшибки,
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(Ошибка.НомерСтроки, "ЧН=0; ЧГ=")));
		Иначе
			СообщитьПользователю(
				СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, "%1", Формат(Ошибка.НомерСтроки + 1, "ЧН=0; ЧГ=")),
				,
				СтрЗаменить(Ошибка.ПолеОшибки, "%1", Формат(Ошибка.НомерСтроки, "ЧН=0; ЧГ=")));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита 
// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
// Для совместного использования с процедурой СообщитьПользователю
// (для передачи в параметры Поле или ПутьКДанным). 
//
// Параметры:
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  НомерСтроки       - Число - номер строки табличной части.
//  ИмяРеквизита      - Строка - имя реквизита.
//
// Возвращаемое значение:
//  Строка - путь к ячейке таблицы.
//
Функция ПутьКТабличнойЧасти(Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита) Экспорт

	Возврат ИмяТабличнойЧасти + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаИсточник - ТаблицаЗначений - таблица, из которой будут браться строки для заполнения;
//  ТаблицаПриемник - ТаблицаЗначений - таблица, в которую будут добавлены строки из таблицы-источника.
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива;
//  Массив  - Массив - массив значений для заполнения таблицы;
//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива.
// 
Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт

	Для каждого Значение Из Массив Цикл
		
		Таблица.Добавить()[ИмяПоля] = Значение;
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения,
//	ТолькоУникальныеЗначения - булево, необязательный, если истина, 
//		то в массив будут включены только те значения, которых в нем еще нет, причем единожды
// 
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт

	УникальныеЗначения = Новый Соответствие;
	
	Если ТолькоУникальныеЗначения Тогда
		Для каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого Значение Из МассивИсточник Цикл
		Если ТолькоУникальныеЗначения И УникальныеЗначения[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивПриемник.Добавить(Значение);
		УникальныеЗначения.Вставить(Значение, Истина);
	КонецЦикла;
	
КонецПроцедуры

// Снимает один элемент условного оформления, если это список значений.
// 
// Параметры:
//  УсловноеОформление - условное оформление элемента формы;
//  ИдентификаторПользовательскойНастройки - строка - идентификатор настройки;
//  Значение - значение, которое требуется удалить из списка оформления.
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения переданного значения из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение;
//  Значение - удаляемое значение из массива.
// 
Процедура УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения значений указанного типа.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значения;
//  Тип – тип значений, которые подлежат удалению из массива.
// 
Процедура УдалитьВсеВхожденияТипаИзМассива(Массив, Тип) Экспорт
	
	КолвоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		Индекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) = Тип Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива.
//
// Параметры:
//  Массив - массив, из которого необходимо удалить значение;
//  Значение - удаляемое значение из массива.
// 
Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	Индекс = Массив.Найти(Значение);
	
	Если Индекс <> Неопределено Тогда
		
		Массив.Удалить(Индекс);
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет коллекцию-приемник значениями из коллекции-источник
// В качестве коллекций источника и приемника могут выступать типы:
// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
//
// Параметры:
//  КоллекцияИсточник - коллекция значений, которая является источником для заполнения данных;
//  КоллекцияПриемник - коллекция значений, которая является приемником для заполнения данных.
// 
Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	
	Для Каждого Элемент Из КоллекцияИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Получает массив значений из отмеченных элементов списка значений.
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений;
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений.
//
Функция ПолучитьМассивОтмеченныхЭлементовСписка(Список) Экспорт
	
	// возвращаемое значение функции
	Массив = Новый Массив;
	
	Для Каждого Элемент Из Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Вычитает один массив элементов из другого массива. Возвращает результат вычитания.
//
// Параметры:
//  Массив - массив элементов, из которого необходимо выполнить вычитание;
//  МассивВычитания - массив элементов, который будет вычитаться.
// 
// Возвращаемое значение:
//  Массив – результат вычитания двух массивов.
//
Функция СократитьМассив(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания;
// 
// Возвращаемое значение:
//  Структура.
//
Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции		

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура;
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания.
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце," + 
		"ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		  ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции		

// Создает копию экземпляра указанного объекта.
//
// Параметры:
//  Источник - Произвольный - объект, который необходимо скопировать.
//
// Возвращаемое значение:
//  Произвольный - копия объекта, переданного в параметре Источник.
//
// Примечание:
//  Функцию нельзя использовать для объектных типов (СправочникОбъект, ДокументОбъект и т.п.).
Функция СкопироватьРекурсивно(Источник) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ИначеЕсли ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Приемник = Источник.Скопировать();
	#КонецЕсли
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает копию значения типа Структура.
//
// Параметры:
//  СтруктураИсточник – Структура – копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие.
//
// Параметры:
//  СоответствиеИсточник – Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив.
//
// Параметры:
//  МассивИсточник – Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений.
//
// Параметры:
//  СписокИсточник – СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Сравнивает элементы списков значений или массивов по значениям
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции // СпискиЗначенийИдентичны

// Создает массив и помещает в него переданное значение
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Процедура управляет состояние поля табличного документа
//
//Параметры:
//  ПолеТабличногоДокумента – ПолеФормы – поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               – Строка – задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = "НеИспользовать") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип("ПолеФормы") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = "НЕИСПОЛЬЗОВАТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = "";
		ИначеЕсли ВРег(Состояние) = "НЕАКТУАЛЬНОСТЬ" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет не сформирован. Нажмите ""Сформировать"" для получения отчета.'");;
		ИначеЕсли ВРег(Состояние) = "ФОРМИРОВАНИЕОТЧЕТА" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр("ru = 'Отчет формируется...'");
		Иначе
			ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''2'')'"));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра (параметр номер ''1'')'"));
	КонецЕсли;
	
КонецПроцедуры

// Получает номер версии конфигурации без номера сборки
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС – номер сборки, который будет удален
// 
//  Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

//	LNK 16.01.2019 11:15:17
Функция СтрокаВерсии(КоличествоЛексем)

	Значение = "";

	Для Счётчик = 1 По КоличествоЛексем Цикл

		Значение = Значение + ?(Значение = "", "", ".") + "0";

	КонецЦикла;

	Возврат Значение;

КонецФункции // СтрокаВерсии()

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2, КоличествоЛексем = 4) Экспорт

	//Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	//Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), СтрокаВерсии(КоличествоЛексем), СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), СтрокаВерсии(КоличествоЛексем), СтрокаВерсии2);
	Версия1 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка1, ".");

	Если НЕ Версия1.Количество() = КоличествоЛексем Тогда

		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		                    НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии1);
	КонецЕсли;

	Версия2 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка2, ".");

	Если НЕ Версия2.Количество() = КоличествоЛексем Тогда

		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	                         НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;

	Для Разряд = 0 По КоличествоЛексем - 1 Цикл

		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);

		Если НЕ Результат = 0 Тогда

			Возврат Результат;

		КонецЕсли;

	КонецЦикла;

	Возврат Результат;
	
КонецФункции

// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
//
// Параметры:
//	Структура - Структура - Структура, ключи которой преобразуются в строку
//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры
//
// Возвращаемое значение:
//	Строка - Строка, содержащая ключи структуры разделенные резделителем
//
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = ",") Экспорт
	
	Результат = "";
	
	Для Каждого Элемент Из Структура Цикл
		
		СимволРазделителя = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для обработки событий и вызова необязательных подсистем.

// Возвращает Истина, если подсистема существует.
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка. Полное имя объекта метаданных подсистема без слов "Подсистема.".
//                        Например: "СтандартныеПодсистемы.БазоваяФункциональность".
//
// Пример вызова необязательной подсистемы:
//
//  Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
//  	МодульУправлениеДоступом = Вычислить("УправлениеДоступом");
//  	МодульУправлениеДоступом.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ИменаПодсистем = СтандартныеПодсистемыПовтИсп.ИменаПодсистем();
#Иначе
	ИменаПодсистем = СтандартныеПодсистемыКлиентПовтИсп.ПараметрыРаботыКлиентаПриЗапуске(
		).ИменаПодсистем;
#КонецЕсли
	
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Модуль = СтандартныеПодсистемыСервер.СерверныйОбщийМодуль(Имя);
#Иначе
	Модуль = СтандартныеПодсистемыКлиент.КлиентскийОбщийМодуль(Имя);
#КонецЕсли
	
	Возврат Модуль;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с файлами
//

// Процедура УдалитьКаталогСФайлами удаляет все файлы в заданном каталоге.
//
// Параметры:
//  Путь         - Строка, полный путь каталога, в котором требуется
//                 удалить все файлы.
//
Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	Если Каталог.Существует() Тогда
		УдалитьФайлы(Путь);
	КонецЕсли;
	
КонецПроцедуры

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
// В случае, когда параметр "Платформа" не указан, разделитель выбирается, исходя из уже имеющихся
// разделителей в параметре "ПутьКаталога".
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу;
//  Платформа - ТипПлатформы - тип платформы, в рамках которой осуществляется работа (влияет на выбор разделителя).
//
// Возвращаемое значение:
//  Строка   - путь к каталогу с конечным символом-разделителем.
//
// Примеры использования:
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("C:\Мой каталог\"); // возвращает "C:\Мой каталог\"
//  Результат = ДобавитьКонечныйРазделительПути("ftp://Мой каталог"); // возвращает "ftp://Мой каталог/"
//	Результат = ДобавитьКонечныйРазделительПути("%APPDATA%", ТипПлатформы.Windows_x86_64); // возвращает "%APPDATA%\"
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Платформа = Неопределено) Экспорт
	
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = "\";
	Если Платформа = Неопределено Тогда
		Если Найти(ПутьКаталога, "/") > 0 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	Иначе
		Если Платформа = ТипПлатформы.Linux_x86 Или Платформа = ТипПлатформы.Linux_x86_64 Тогда
			ДобавляемыйСимвол = "/";
		КонецЕсли;
	КонецЕсли;
	
	Если Прав(ПутьКаталога, 1) <> ДобавляемыйСимвол Тогда
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	Иначе 
		Возврат ПутьКаталога;
	КонецЕсли;
	
КонецФункции


// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьПолноеИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

// Раскладывает полное имя файла на составляющие.
//
// Параметры
//  ПолноеИмяФайла – Строка, содержащая полный путь к файлу.
//  ЭтоПапка – Булево, признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура – имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - Содержит путь к каталогу, в котором лежит файл.
//		Имя - Содержит имя файла с расширением, без пути к файлу.
//		Расширение - Содержит расширение файла
//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = "c:\temp\test.txt", то структура заполнится следующим образом:
//				ПолноеИмя: "c:\temp\test.txt"
//				Путь: "c:\temp\"
//				Имя: "test.txt"
//				Расширение: ".txt"
//				ИмяБезРасширения: "test"
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура("ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения");
	
	// Убираем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = "/" Или Прав(ПолноеИмяФайла, 1) = "\") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Путь", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить("Имя", ""); 
			СтруктураИмениФайла.Вставить("Расширение", ""); 
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("ПолноеИмя", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым, то остальные параметры структуры возвращаем пустыми
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить("Путь", ""); 
		СтруктураИмениФайла.Вставить("Имя", ""); 
		СтруктураИмениФайла.Вставить("Расширение", ""); 
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", ""); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла
	Если Найти(ПолноеИмяФайла, "/") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "/");
	ИначеЕсли Найти(ПолноеИмяФайла, "\") > 0 Тогда
		ПозицияРазделителя = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(ПолноеИмяФайла, "\");
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить("Путь", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить("Имя", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить("Расширение", "");
		СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
	Иначе
        ПозицияТочки = СтроковыеФункцииКлиентСервер.НайтиСимволСКонца(СтруктураИмениФайла.Имя, ".");
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить("Расширение", "");
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить("Расширение", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить("ИмяБезРасширения", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Функция раскладывает Строку в массив строк, используя "./\" как разделитель.
Функция РазложитьСтрокуПоТочкамИСлэшам(Знач Строка) Экспорт
	
	Перем ТекущаяПозиция;
	
	Фрагменты = Новый Массив;
	
	НачальнаяПозиция = 1;
	
	Для ТекущаяПозиция = 1 По СтрДлина(Строка) Цикл
		ТекущийСимвол = Сред(Строка, ТекущаяПозиция, 1);
		Если ТекущийСимвол = "." Или ТекущийСимвол = "/" Или ТекущийСимвол = "\" Тогда
			ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
			НачальнаяПозиция = ТекущаяПозиция + 1;
			Фрагменты.Добавить(ТекущийФрагмент);
		КонецЕсли;
	КонецЦикла;
	
	Если НачальнаяПозиция <> ТекущаяПозиция Тогда
		ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
		Фрагменты.Добавить(ТекущийФрагмент);
	КонецЕсли;
	
	Возврат Фрагменты;
	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры:
//  ИмяФайла – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеИмениФайла(Знач ИмяФайла) Экспорт
	
	Расширение = "";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = "." Тогда
			
			Расширение = Сред(ИмяФайла, ПозицияСимвола + 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат Расширение;
	
КонецФункции

// Преобразует расширение файла в нижний регистр без точки.
//
// Параметры:
//  Расширение - Строка. Расширение для преобразования.
//
// Возвращаемое значение:
//  Строка.
//
Функция РасширениеБезТочки(Знач Расширение) Экспорт
	
	Расширение = НРег(СокрЛП(Расширение));
	
	Если Сред(Расширение, 1, 1) = "." Тогда
		Расширение = Сред(Расширение, 2);
	КонецЕсли;
	
	Возврат Расширение;
	
КонецФункции

// Возвращает разделитель пути файловой системы.
// 
// Параметры:
//  Платформа - Неопределено:
//                На клиенте - разделитель пути клиентской файловой системы.
//                На сервере - разделитель пути серверной  файловой системы.
// 
//            - ТипПлатформы - разделитель пути файловой системы для
//                             указанного типа платформы.
//
Функция РазделительПути(Платформа = Неопределено) Экспорт
	
	Если Платформа = Неопределено Тогда
		
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		Платформа = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера(Ложь);
	#Иначе
		Платформа = ОбщегоНазначенияКлиентПовтИсп.ТипПлатформыКлиента();
	#КонецЕсли
	
	КонецЕсли;
	
	Если Платформа = ТипПлатформы.Windows_x86
	 ИЛИ Платформа = ТипПлатформы.Windows_x86_64 Тогда
		
		Возврат "\";
	Иначе
		Возврат "/";
	КонецЕсли;
	
КонецФункции

// Возвращает имя файла с расширением.
// Если расширение пустое, тогда точка не добавляется.
//
// Параметры:
//  ИмяБезРасширения - Строка.
//  Расширение       - Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИмяСРасширением(ИмяБезРасширения, Расширение) Экспорт
	
	ИмяСРасширением = ИмяБезРасширения;
	
	Если Расширение <> "" Тогда
		ИмяСРасширением = ИмяСРасширением + "." + Расширение;
	КонецЕсли;
	
	Возврат ИмяСРасширением;
	
КонецФункции

// Возвращает строку недопустимых символов.
// Согласно http://en.wikipedia.org/wiki/Filename - в разделе "Reserved characters and words"
// Возвращаемое значение:
//   Строка - строка недопустимых символов
Функция ПолучитьНедопустимыеСимволыВИмениФайла() Экспорт

	НедопустимыеСимволы = """/\[]:;|=?*<>";
	Возврат НедопустимыеСимволы;

КонецФункции

// Проверяет наличие недопустимых символов в имени файла.
//
// Параметры
//  ИмяФайла  - Строка 
// Возвращаемое значение:
//   Массив   - массив обнаруженных в имени файла недопустимых символов.
//              Если недопустимых символов не обнаружено возвращается пустой массив.
Функция НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла) Экспорт

	НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
	
	МассивНайденныхНедопустимыхСимволов = Новый Массив;
	
	Для ПозицияСимвола = 1 По СтрДлина(НедопустимыеСимволы) Цикл
		ПроверяемыйСимвол = Сред(НедопустимыеСимволы,ПозицияСимвола,1);
		Если Найти(ИмяФайла,ПроверяемыйСимвол) <> 0 Тогда
			МассивНайденныхНедопустимыхСимволов.Добавить(ПроверяемыйСимвол);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивНайденныхНедопустимыхСимволов;

КонецФункции

// Заменяет недопустимые символы в имени файла.
//
// Параметры
//  ИмяФайла     - Строка - исходное имя файла.
//  НаЧтоМенять  - Строка - строка, на которую необходимо заменить недопустимые символы.
//
// Возвращаемое значение:
//   Строка - преобразованное имя файла.
//
Функция ЗаменитьНедопустимыеСимволыВИмениФайла(Знач ИмяФайла, НаЧтоМенять = " ") Экспорт

	Результат = ИмяФайла;
	МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(Результат);
	Для Каждого НедопустимыйСимвол Из МассивНайденныхНедопустимыхСимволов Цикл
		Результат = СтрЗаменить(Результат, НедопустимыйСимвол, НаЧтоМенять);
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с почтовыми адресами
//

// Разбирает строку с адресами электронной почты согласно стандарту RFC 5322 с ограничениями.
//
// Ограничения:
//  1. В адресе разрешаются только буквы, цифры, символ подчеркивания, дефис и символ "@".
//  2. Символы скобок "<>[]()" допускаются, но игнорируются путём замены на пробелы.
//  3. Группы запрещены.
//
// Параметры:
//  Строка - Строка - Строка, содержащая электронные адреса (mailbox-list).
//
// Возвращаемое значение:
//  Массив - содержит массив структур адресов.
//           Поля структуры:
//             Псевдоним      - Строка - представление адресата.
//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
//                                       стандартов, то такой текст записывается в поле "Псевдоним".
//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.
Функция АдресаЭлектроннойПочтыИзСтроки(Знач Строка) Экспорт
	
	Результат = Новый Массив;
	
	// заменяем скобки на пробелы
	СимволыСкобок = "<>()[]";
	Строка = ЗаменитьСимволыВСтрокеНаПробелы(Строка, СимволыСкобок);
	
	// приводим разделители к одному виду
	Строка = СтрЗаменить(Строка, ",", ";");
	
	// раскладываем mailbox-list на mailbox'ы
	МассивАдресов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка, ";", Истина);
	
	// допустимые символы для псевдонима (display-name)
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	ДополнительныеСимволы = "._- ";
	
	// выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec)
	Для Каждого СтрокаАдреса Из МассивАдресов Цикл
		
		Псевдоним = "";
		Адрес = "";
		ОписаниеОшибки = "";
		
		Если СтрЧислоВхождений(СтрокаАдреса, "@") <> 1 Тогда
			Псевдоним = СтрокаАдреса;
		Иначе
			// всё, что не подходит в качестве адреса, складываем в псевдоним
			Для Каждого Подстрока Из СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаАдреса, " ") Цикл
				Если ПустаяСтрока(Адрес) И АдресЭлектроннойПочтыСоответствуетТребованиям(Подстрока) Тогда
					Адрес = Подстрока;
				Иначе
					Псевдоним = Псевдоним + " " + Подстрока;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Псевдоним = СокрЛП(Псевдоним);
		
		// проверки
		ЕстьНедопустимыеСимволыВПсевдониме = Не СтрокаСодержитТолькоДопустимыеСимволы(НРег(Псевдоним), Буквы + Цифры + ДополнительныеСимволы);
		АдресОпределен = Не ПустаяСтрока(Адрес);
		ЕстьПризнакНаличияАдресаВСтроке = Найти(СтрокаАдреса, "@") > 0;
		
		Если АдресОпределен Тогда 
			Если ЕстьНедопустимыеСимволыВПсевдониме Тогда
				ОписаниеОшибки = НСтр("ru = 'Представление содержит недопустимые символы'");
			КонецЕсли;
		Иначе
			Если ЕстьПризнакНаличияАдресаВСтроке Тогда 
				ОписаниеОшибки = НСтр("ru = 'Адрес электронной почты содержит ошибки'");
			Иначе
				ОписаниеОшибки = НСтр("ru = 'Строка не содержит адреса электронной почты'");
			КонецЕсли;
		КонецЕсли;	
		
		СтруктураАдреса = Новый Структура("Псевдоним,Адрес,ОписаниеОшибки", Псевдоним, Адрес, ОписаниеОшибки);
		Результат.Добавить(СтруктураАдреса);
	КонецЦикла;
	
	Возврат Результат;	
	
КонецФункции

// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
// а также RFC 5335, RFC 5336 и RFC 3696.
// Кроме того, функция ограничивает использование спецсимволов.
// 
// Параметры:
//  Адрес - Строка - проверяемый email.
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Знач Адрес) Экспорт
	
	// допустимые символы для email
	Буквы = "abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Цифры = "0123456789";
	СпецСимволы = ".@_-";
	
	// проверяем любые сочетания спецсимволов
	Если СтрДлина(СпецСимволы) > 1 Тогда
		Для Позиция1 = 1 По СтрДлина(СпецСимволы)-1 Цикл
			Символ1 = Сред(СпецСимволы, Позиция1, 1);
			Для Позиция2 = Позиция1 + 1 По СтрДлина(СпецСимволы) Цикл
				Символ2 = Сред(СпецСимволы, Позиция2, 1);
				Комбинация1 = Символ1 + Символ2;
				Комбинация2 = Символ2 + Символ1;
				Если Найти(Адрес, Комбинация1) > 0 Или Найти(Адрес, Комбинация2) > 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	// проверяем символ @
	Если СтрЧислоВхождений(Адрес, "@") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	   
	// проверяем две точки подряд
	Если Найти(Адрес, "..") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// приводим строку адреса к нижнему регистру
	Адрес = НРег(Адрес);
	
	// проверяем допустимые символы
	Если Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// разбираем адрес на local-part и domain
	Позиция = Найти(Адрес,"@");
	ЛокальноеИмя = Лев(Адрес, Позиция - 1);
	Домен = Сред(Адрес, Позиция + 1);
	
	// проверяем на заполненность и допустимость длины
	Если ПустаяСтрока(ЛокальноеИмя)
	 	Или ПустаяСтрока(Домен)
		Или СтрДлина(ЛокальноеИмя) > 64
		Или СтрДлина(Домен) > 255 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем наличие спецсимволов в начале и в конце частей адреса
	Если ЕстьСимволыВНачалеВКонце(ЛокальноеИмя, СпецСимволы) Или ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене должна быть минимум одна точка
	Если Найти(Домен,".") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// в домене не должно быть символа подчеркивания
	Если Найти(Домен,"_") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// выделяем зону (TLD) из имени домена 
	Зона = Домен;
	Позиция = Найти(Зона,".");
	Пока Позиция > 0 Цикл
		Зона = Сред(Зона, Позиция + 1);
		Позиция = Найти(Зона,".");
	КонецЦикла;
	
	// проверяем зону домена (минимум 2 символа, только буквы)
	Возврат СтрДлина(Зона) >= 2 И СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
	
КонецФункции

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаПереданныхАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаПереданныхАдресов, ВызыватьИсключение = Истина) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	
	СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимый символ %1 в адресе электронной почты %2'");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Некорректный адрес электронной почты %1'");
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов,";",Истина);
	МассивПодстрокКОбработке = Новый Массив;
	
	Для каждого ЭлементМассива Из МассивПодстрок Цикл
		Если Найти(ЭлементМассива,",") > 0 Тогда
			ДопМассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаПереданныхАдресов);
			Для каждого ЭлементДопМассива Из ДопМассивПодстрок Цикл
				МассивПодстрокКОбработке.Добавить(ЭлементДопМассива);
			КонецЦикла;
		Иначе
			МассивПодстрокКОбработке.Добавить(ЭлементМассива);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого СтрокаАдреса Из МассивПодстрокКОбработке Цикл
		
		Индекс = 1;               // номер обрабатываемого символа
		Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
		// либо в почтовый адрес
		ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
		ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
		// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
		// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
		// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
		СтадияРазбора = 1; 
		
		Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
			
			Символ = Сред(СтрокаАдреса, Индекс, 1);
			
			Если      Символ = " " Тогда
				Индекс = ? ((ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1) > Индекс,
				ПропуститьПробелы(СтрокаАдреса, Индекс, " ") - 1,
				Индекс);
				Если      СтадияРазбора = 1 Тогда
					ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
				ИначеЕсли СтадияРазбора = 2 Тогда
					ПочтовыйАдрес = Накопитель;
					СтадияРазбора = 3;
				КонецЕсли;
				Накопитель = "";
			ИначеЕсли Символ = "@" Тогда
				Если      СтадияРазбора = 1 Тогда
					СтадияРазбора = 2;
					
					Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
						Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 И ВызыватьИсключение Тогда
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							                  СообщениеНедопустимыеСимволы,Сред(Накопитель, ИндексПоискаНС, 1),СтрокаАдреса);
						КонецЕсли;
					КонецЦикла;
					
					Накопитель = Накопитель + Символ;
				ИначеЕсли СтадияРазбора = 2 И ВызыватьИсключение Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				ИначеЕсли СтадияРазбора = 3 И ВызыватьИсключение Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					                  СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				КонецЕсли;
			Иначе
				Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
					Если Найти(НедопустимыеСимволы, Символ) > 0 И ВызыватьИсключение Тогда
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						                  СообщениеНедопустимыеСимволы,Символ,СтрокаАдреса);
					КонецЕсли;
				КонецЕсли;
				
				Накопитель = Накопитель + Символ;
			КонецЕсли;
			
			Индекс = Индекс + 1;
		КонецЦикла;
		
		Если      СтадияРазбора = 1 Тогда
			ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
		ИначеЕсли СтадияРазбора = 2 Тогда
			ПочтовыйАдрес = Накопитель;
		КонецЕсли;
		
		Если ПустаяСтрока(ПочтовыйАдрес) И (Не ПустаяСтрока(ПолноеИмяАдресата)) И ВызыватьИсключение Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПолноеИмяАдресата);
		ИначеЕсли СтрЧислоВхождений(ПочтовыйАдрес,"@") <> 1 И ВызыватьИсключение Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			                  СообщениеНеверныйФорматПочтовогоАдреса,ПочтовыйАдрес);
		КонецЕсли;
		
		Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
			Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами динамических списков
//

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьПоиска - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Функция НайтиЭлементыИГруппыОтбора(знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление группы отбора
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  ТипГруппы - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы
//  Представление строка - представление группы
//
Функция СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	Если ТипЗнч(КоллекцияЭлементов) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавление элемента компоновки в контейнер элементов компоновки
// Параметры:
//  ОбластьДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменение элементов отбора
// Параметры
//  ИмяПоля - строка - имя поля компоновки
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - строка - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Поиск элементов и групп отбора динамического списка
// Параметры:
//  ОбластьУдаления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - имя поля компоновки (не используется для групп)
//  Представление - представление поля компоновки
//  Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Процедура УдалитьЭлементыГруппыОтбора(знач ОбластьУдаления,
										знач ИмяПоля = Неопределено,
										знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств
// Параметры
//  ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//                  Список.Отбор или группа в отборе
//  ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
// Устанавливаемые поля:
//  ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
//  ПравоеЗначение - произвольный
//  Представление - представление элемента компоновки данных
//  Использование - булево - использование элемента
//  РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено,
								знач РежимОтображения = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения);
	КонецЕсли;
	
КонецПроцедуры

// Добавляет / заменяет существующий элемент отбора динамического списка.
//   Работает для платформы версии 8.3.
//
// Параметры:
//   ДинамическийСписок (ДинамическийСписок) Реквизит формы, для которого требуется установить отбор.
//   Остальные параметры - см. УстановитьЭлементОтбора()
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля,
	ПравоеЗначение = Неопределено,
	ВидСравнения = Неопределено,
	Представление = Неопределено,
	Использование = Неопределено,
	РежимОтображения = Неопределено) Экспорт
	
	Если Платформа83БезИспользованияРежимаСовместимости() Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.Отбор;
	КонецЕсли;
	
	УстановитьЭлементОтбора(
		ОтборДинамическогоСписка,
		ИмяПоля,
		ПравоеЗначение,
		ВидСравнения,
		Представление,
		Использование,
		РежимОтображения
	);
	
КонецПроцедуры

// Устанавливает значение Значение параметра ИмяПараметра динамического списка Список 
// или отключает его использование в зависимости от признака Использование.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	Если Использование Тогда
		Список.Параметры.УстановитьЗначениеПараметра(ИмяПараметра, Значение);
	Иначе
		ЗначениеПараметра = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
		Если ЗначениеПараметра <> Неопределено Тогда
			ЗначениеПараметра.Значение = Значение;
			ЗначениеПараметра.Использование = Ложь;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры 

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с управляемыми формами
//

// Получает значение реквизита формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Устанавливает значение реквизиту формы
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления"
//		Значение
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению
//
// Параметры:
//  КоллекцияЭлементов - контейнер с элементами и группами отбора, например
//                      Список.Отбор.Элементы или группа в отборе
//  Представление строка - представление группы
// 
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы
//  Значение      - Произвольный - новое значение элемента
// 
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение) Экспорт
	
	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Если ЭлементФормы <> Неопределено Тогда
		ЭлементФормы[ИмяСвойства] = Значение;
	КонецЕсли;
	
КонецПроцедуры 

// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - свойство ЭлементыФормы управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы
//  ИмяСвойства   - Строка       - имя свойства элемента формы
// 
// Возвращаемое значение:
//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
// 
Функция ЗначениеСвойстваЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства) Экспорт
	
	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Возврат ?(ЭлементФормы <> Неопределено, ЭлементФормы[ИмяСвойства], Неопределено);
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Прочие функции
//

// Возвращает шаблон структуры параметров для установки внешнего соединения.
// Параметрам необходимо задать требуемые значения и передать
// в метод ОбщегоНазначения.УстановитьВнешнееСоединение()
//
Функция СтруктураПараметровДляУстановкиВнешнегоСоединения() Экспорт
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ВариантРаботыИнформационнойБазы", 0);
	СтруктураПараметров.Вставить("КаталогИнформационнойБазы", "");
	СтруктураПараметров.Вставить("ИмяСервера1СПредприятия", "");
	СтруктураПараметров.Вставить("ИмяИнформационнойБазыНаСервере1СПредприятия", "");
	СтруктураПараметров.Вставить("АутентификацияОперационнойСистемы", Ложь);
	СтруктураПараметров.Вставить("ИмяПользователя", "");
	СтруктураПараметров.Вставить("ПарольПользователя", "");
	
	Возврат СтруктураПараметров;
КонецФункции

// Извлекает из строки соединения с информационной базой параметры подключения
// и передает параметры в структуру для установки внешнего соединения.
//
Функция ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(Знач СтрокаСоединения) Экспорт
	
	Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
	
	Параметры = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединения);
	
	Параметры.Свойство("File", Результат.КаталогИнформационнойБазы);
	Параметры.Свойство("Srvr", Результат.ИмяСервера1СПредприятия);
	Параметры.Свойство("Ref",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
	
	Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство("File"), 0, 1);
	
	Возврат Результат;
КонецФункции

// Для файлового режима работы возвращает полное имя каталога, в котором расположена информационная база.
// Если режим работы клиент-серверный, то возвращается пустая строка.
//
// Параметры:
//  Нет.
// 
//  Возвращаемое значение:
// Тип: Строка. Полное имя каталога, в котором расположена файловая информационная база.
//
Функция КаталогФайловойИнформационнойБазы() Экспорт
	
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	
	Если ПараметрыСоединения.Свойство("File") Тогда
		Возврат ПараметрыСоединения.File;
	КонецЕсли;
	
	Возврат "";
КонецФункции

// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки дерева.
// Используется для позиционирования курсора в иерархических списках.
// 
Процедура ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск) Экспорт
	
	Для Каждого СтрокаДерева Из КоллекцияЭлементовДерева Цикл
		
		Если ПрекратитьПоиск Тогда
			Возврат;
		КонецЕсли;
		
		Если СтрокаДерева[ИмяПоля] = КлючСтроки Тогда
			
			ИдентификаторСтроки = СтрокаДерева.ПолучитьИдентификатор();
			
			ПрекратитьПоиск = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		КоллекцияЭлементов = СтрокаДерева.ПолучитьЭлементы();
		
		Если КоллекцияЭлементов.Количество() > 0 Тогда
			
			ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементов, КлючСтроки, ПрекратитьПоиск);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет недопустимые символы в XML-строке на заданные символы
//
// Параметры:
//   Текст – Строка – строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены – Строка – строка, на которую требуется выполнить замену недопустимого символа в XML-строке
// 
//  Возвращаемое значение:
//    Строка - cтрока, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, СимволЗамены = " ") Экспорт
	
#Если НЕ ВебКлиент Тогда
	ПозицияНачала = 1;
	Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	Пока Позиция > 0 Цикл
		НедопустимыйСимвол = Сред(Текст, Позиция, 1);
		Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
		ПозицияНачала = Позиция + СтрДлина(СимволЗамены);
		Если ПозицияНачала > СтрДлина(Текст) Тогда
			Прервать;
		КонецЕсли;
		Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	КонецЦикла;
	
	Возврат Текст;
#Иначе
	// Коды символов от 0 до 2^16-1, которые метод НайтиНедопустимыеСимволыXML
	// считает недопустимыми: 0-8, 11-12, 14-31, 55296-57343.
	Итог = "";
	ДлинаСтроки = СтрДлина(Текст);
	
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Символ = Сред(Текст, НомерСимвола, 1);
		КодСимвола = КодСимвола(Символ);
		
		Если КодСимвола < 9
		 Или КодСимвола > 10    И КодСимвола < 13
		 Или КодСимвола > 13    И КодСимвола < 32
		 Или КодСимвола > 55295 И КодСимвола < 57344 Тогда
			
			Символ = " ";
		КонецЕсли;
		Итог = Итог + Символ;
	КонецЦикла;
	
	Возврат Итог;
#КонецЕсли
	
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст – Строка – строка, в которой требуется удалить недопустимые символы.
// 
//  Возвращаемое значение:
//  Тип: Строка. Строка, полученная при удалении недопустимых символов в XML-строке.
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	Возврат ЗаменитьНедопустимыеСимволыXML(Текст, "");
	
КонецФункции

// Сравнивает расписания между собой.
//
// Параметры
//	Расписание1, Расписание2 - РасписаниеРегламентногоЗадания
//
// Возвращаемое значение
//  Булево - истина, если расписания идентичны, иначе ложь.
Функция РасписанияОдинаковые(Знач Расписание1, Знач Расписание2) Экспорт
	Расписание1 = РасписаниеВСтруктуру(Расписание1);
	Расписание2 = РасписаниеВСтруктуру(Расписание2);
	
	Для Каждого РеквизитРасписания Из Расписание1 Цикл
		Если ТипЗнч(РеквизитРасписания.Значение) <> Тип("Массив") Тогда
			Если РеквизитРасписания.Значение <> Расписание2[РеквизитРасписания.Ключ] Тогда
				Возврат Ложь;
			КонецЕсли;
		Иначе
			Если РеквизитРасписания.Значение.Количество() <> Расписание2[РеквизитРасписания.Ключ].Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для НомерЭлемента = 0 По РеквизитРасписания.Значение.Количество()-1 Цикл
				Если РеквизитРасписания.Ключ = "ДетальныеРасписанияДня" Тогда
					Если Не РасписанияОдинаковые(РеквизитРасписания.Значение[НомерЭлемента],Расписание2[РеквизитРасписания.Ключ][НомерЭлемента]) Тогда
						Возврат Ложь;
					КонецЕсли;
				Иначе
					Если РеквизитРасписания.Значение[НомерЭлемента] <> Расписание2[РеквизитРасписания.Ключ][НомерЭлемента] Тогда
						Возврат Ложь;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Возвращает код основного языка конфигурации, например "ru".
Функция КодОсновногоЯзыка() Экспорт
	#Если Клиент Тогда
		Возврат СтандартныеПодсистемыКлиентПовтИсп.ПараметрыРаботыКлиента().КодОсновногоЯзыка;
	#Иначе
		Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	#КонецЕсли
КонецФункции

// Возвращает Истина если конфигурация запущена под управлением платформы 8.3 без использования режима совместимости.
Функция Платформа83БезИспользованияРежимаСовместимости() Экспорт
	#Если Клиент Тогда
		Возврат СтандартныеПодсистемыКлиентПовтИсп.ПараметрыРаботыКлиента().Платформа83БезИспользованияРежимаСовместимости;
	#Иначе
		Возврат СтандартныеПодсистемыСервер.Платформа83БезИспользованияРежимаСовместимости();
	#КонецЕсли
КонецФункции

// Возвращает Истина, если клиентское приложение подключено к базе через веб-сервер.
// Если подключение не клиентское возвращает Ложь.
//
Функция КлиентПодключенЧерезВебСервер() Экспорт
	
#Если Клиент Или ВнешнееСоединение Тогда
	СтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы();
#Иначе
	УстановитьПривилегированныйРежим(Истина);
	
	СтрокаСоединенияИнформационнойБазы = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере(
		).Получить("СтрокаСоединенияИнформационнойБазы");
	
	Если СтрокаСоединенияИнформационнойБазы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
#КонецЕсли
	
	Возврат Найти(ВРег(СтрокаСоединенияИнформационнойБазы), "WS=") = 1;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Устаревшие процедуры и функции

// Устарела. Следует использовать РазделительПути.
Функция ПолучитьСлеш(Платформа = Неопределено) Экспорт
	
	Возврат РазделительПути(Платформа);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Функция выполняет поиск элемента в коллекции: списке значений или массиве
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип("СписокЗначений") Тогда
		Если ТипЗнч(Элемент) = Тип("ЭлементСпискаЗначений") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип("Массив") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции // ЭлементПрисутствуетВСписке

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗаменитьСимволыВСтрокеНаПробелы(Строка, ЗаменяемыеСимволы)
	Результат = Строка;
	Для Позиция = 1 По СтрДлина(Символы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Позиция, 1), " ");
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЕстьСимволыВНачалеВКонце(Строка, ПроверяемыеСимволы)
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = (Лев(Строка,1) = Символ) Или (Прав(Строка,1) = Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы)
	МассивСимволов = Новый Массив;
	Для Позиция = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

//	LNK 18.08.2016
//	---------------------------------------------------------------------------------------

#Область БиблиотекаПроцедур
 
Функция ADD(Source, AddArray)		Экспорт

	UniqueValues = Новый Соответствие;

	Для каждого Item Из Source Цикл

		UniqueValues.Insert(Item, True);

	КонецЦикла;

	Если ТипЗнч(AddArray) = Тип("Массив") Тогда

		Для каждого Item Из AddArray Цикл

			Если UniqueValues[Item] = Undefined Тогда

				Source.Add(Item);
				UniqueValues.Insert(Item, True);

			КонецЕсли;

		КонецЦикла; 

	Иначе

		Если UniqueValues[AddArray] = Undefined Тогда

			Source.Add(AddArray);

		КонецЕсли;

	КонецЕсли;

	Возврат Source;

КонецФункции

Функция AAD(Параметр1 = NULL, Параметр2 = NULL, Параметр3 = NULL,
			Параметр4 = NULL, Параметр5 = NULL, Параметр6 = NULL,
			Параметр7 = NULL, Параметр8 = NULL, Параметр9 = NULL)	Экспорт

	AddArray	 = Новый Массив;
	ТекстКоманды =
	"Если НЕ Параметр# = NULL Тогда
	|	AddArray.Добавить(Параметр#);
	|КонецЕсли;";

	Для Счётчик = 1 По 9 Цикл

		Выполнить СтрЗаменить(ТекстКоманды, "#", Формат(Счётчик, "ЧДЦ=0; ЧН=0; ЧГ="));

	КонецЦикла;

	Возврат AddArray;

КонецФункции

Функция ACOPY(МассивОригинал)	Экспорт

	МассивКопия = Новый Массив;

	Если ТипЗнч(МассивОригинал) = Тип("Массив") Тогда

		Для каждого Элемент Из МассивОригинал Цикл

			МассивКопия.Добавить(Элемент);

		КонецЦикла;

	КонецЕсли;

	Возврат МассивКопия;

КонецФункции

Функция ВМассив(Знач ТипЗначения, Знач СтрокаЗначений, Разделитель = ",", СократитьПробелы = Ложь)	Экспорт	//	LNK 04.02.2020 11:17:14

	МассивЗначений = Новый Массив;

	ТипЗначения = Новый ОписаниеТипов(ТипЗначения);
	СтрокаЗначений = СтрЗаменить(СтрокаЗначений, Разделитель, Символы.ПС);

	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаЗначений) Цикл

		Попытка

			Значение = СтрПолучитьСтроку(СтрокаЗначений, НомерСтроки);

			Если СократитьПробелы = Истина Тогда

				Значение = СокрЛП(Значение);

			КонецЕсли;

			МассивЗначений.Добавить(ТипЗначения.ПривестиЗначение(Значение));

		Исключение

			МассивЗначений.Добавить(ТипЗначения.ПривестиЗначение());

		КонецПопытки;

	КонецЦикла;

	Возврат МассивЗначений;

КонецФункции

Функция СТОП(Значение, ЗначениеПоУмолчанию = Неопределено)	Экспорт

	Значение = ЗначениеПоУмолчанию;

	Возврат Значение;

КонецФункции // СТОП()

Функция ЗначениеКлючаСтруктуры(СтруктураДанных, ИмяКлюча, ЗначениеПоУмолчанию = Неопределено, ТипПустого = Неопределено)	Экспорт

	ЗначениеВозврата = ЗначениеПоУмолчанию;

	Если СтруктураДанных.Свойство(ИмяКлюча) Тогда

		Если ТипЗнч(ТипПустого) = Тип("ОписаниеТипов") Тогда

			ПринятьЗначение = НЕ СтруктураДанных[ИмяКлюча] = ТипПустого.ПривестиЗначение();

		Иначе

			ПринятьЗначение = Истина;

		КонецЕсли;

		Если ПринятьЗначение Тогда

			ЗначениеВозврата = СтруктураДанных[ИмяКлюча];

		КонецЕсли;

	КонецЕсли;

	Возврат ЗначениеВозврата;

КонецФункции

Процедура Пауза(ИнтервалОжидания = 1000, ЭтоТочноWindows = Ложь) Экспорт

	Перем Платформа;

	Если ЭтоТочноWindows = Ложь Тогда

		Платформа = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера(Ложь);

	КонецЕсли;

	Если Платформа = ТипПлатформы.Linux_x86_64 ИЛИ Платформа = ТипПлатформы.Linux_x86 Тогда

		ВремяЗавершения = ТекущаяДата() + (ИнтервалОжидания / 1000);

		Пока ТекущаяДата() < ВремяЗавершения Цикл
		КонецЦикла;

	Иначе

		#Если ВебКлиент Тогда
		ИмяКомандногоФайла = КаталогВременныхФайлов() + "sleep.js";
		#Иначе
		ИмяКомандногоФайла = ПолучитьИмяВременногоФайла("js");
		#КонецЕсли

		Скрипт = Новый ТекстовыйДокумент;
		Скрипт.Вывод = ИспользованиеВывода.Разрешить;
	    Скрипт.УстановитьТекст(
	    "if (WScript.Arguments.Count()==0)
	    |    WScript.Quit();
	    |else
	    |    if (isNaN(parseInt(WScript.Arguments(0))))
	    |        WScript.Quit();
	    |WScript.Sleep(WScript.Arguments(0));"
	    );
	    Скрипт.Записать(ИмяКомандногоФайла, КодировкаТекста.ANSI);

	    WshShell = Новый COMОбъект("wscript.shell");
	    WshShell.Run("wscript.exe """ + ИмяКомандногоФайла + """ " + Формат(ИнтервалОжидания, "ЧГ=0"), 0, -1);
	    УдалитьФайлы(ИмяКомандногоФайла);

	КонецЕсли;

КонецПроцедуры

#Область ГенерацияСлучайногоЧисла

Функция RANDOM(МинЗначение, МаксЗначение, ГСЧ = Неопределено)	Экспорт

//	Уникальность случайного числа должна обеспечиваться передачей
//	параметра "ГСЧ".
//	Такой манёвр обязательно нужно делать в случае циклического получения
//	случайного числа, что исключит созданияе НОВЫХ объектов ГСЧ,
//	которые могут быть инициализированы одним и тем же моментом времени
//	в пределах милисекунды.

	Если ГСЧ = Неопределено Тогда

		ГСЧ = Новый ГенераторСлучайныхЧисел;

	КонецЕсли;

	Возврат ГСЧ.СлучайноеЧисло(МинЗначение, МаксЗначение);

КонецФункции

Функция RANDOM_COM(MinValue = 0, MaxValue = 0, Object = Неопределено)	Экспорт	//	LNK 28.01.2020 10:01:19

//	Уникальность случайного числа должна обеспечиваться передачей
//	параметра "Object" (кешируемая переменная).
//	Такой манёвр обязательно нужно делать в случае циклического получения
//	случайного числа, что исключит создание НОВЫХ объектов ГСЧ,
//	которые могут быть инициализированы одним и тем же моментом времени
//	в пределах милисекунды.

	Если Object = Неопределено Тогда

		Object = Новый COMОбъект("MSScriptControl.ScriptControl");
		Object.Language = "vbscript";
		Object.executeStatement("randomize");

	КонецЕсли;

	ReturnValue = Object.eval("rnd");

	Если MinValue < MaxValue Тогда

	//	Задан ограничительный диапазон...
		ReturnValue = Цел(ReturnValue * (MaxValue - MinValue + 1)) + MinValue;

	Иначе

		ReturnValue = ReturnValue * 100;

	КонецЕсли;

	Возврат ReturnValue;

КонецФункции

#КонецОбласти
 
Функция REPEAT(Char, Val Count = 0)	Экспорт

	Если НЕ(Count = 0) Тогда
		
			Result = СтрЗаменить(Формат(0, "ЧЦ=" + TrimAll(Count) + "; ЧН=; ЧВН=; ЧГ="), "0", Char);
		
	Иначе	Result	= "";
		
	КонецЕсли; 

	Возврат (Result);
КонецФункции // REPEAT()

Функция PAD(Val String, Lenght, Left = True, Char = " ", Cut = False)		Экспорт

	Pad		= REPEAT(Char, Lenght - СтрДлина(String));
	String	= ?(Left, Pad, "") + String + ?(НЕ Left, Pad, "");

	Если (Cut) Тогда

		Если (Left) Тогда
			
				String	= Right(String,Lenght);
				
		Иначе	String	= Left(String,Lenght);
				
		КонецЕсли; 
		
	КонецЕсли;
	
	Возврат String;

КонецФункции // PAD()

#Область БлокРаботыСЛексемами

Процедура ToArrayOfDelimiters(TexT, Delimiters, AddDelims = False, ClearEmpty = True)	Экспорт

    TexT = ?(ТипЗнч(TexT) = Тип("Строка"), TexT, TrimAll(TexT));
//	В этом месте не лишним было бы убрать возможные непрерывные
//	повторения разделителей... но, пока так!
	
	Lenght = StrLen(Delimiters);	//	Количество разделителей.

	Для Position = 1 По Lenght Цикл

		NextChar = Mid(Delimiters, Position, 1);
		Delim    = ?(НЕ AddDelims ИЛИ (NextChar = " "), "", NextChar) + Chars.LF;
		TexT     = StrReplace(TexT, NextChar, Delim);

		Если ClearEmpty Тогда

		//	Необходимо очистить от возможного "концевого" разделителя.
			TexT = ?(Right(TexT, 1) = NextChar, Left(TexT, StrLen(TexT) - 1), TexT);

		КонецЕсли; 

	КонецЦикла;

	Если ClearEmpty Тогда

	//	Получили что-то... Необходимо заменить возможные повторения
	//	символа перевода строки, т.к. разделителей могло быть несколько!
		Double	= Chars.LF + Chars.LF;

		Пока НЕ(Find(TexT, Double) = 0) Цикл

			TexT = StrReplace(TexT, Double, Chars.LF);

		КонецЦикла;

	КонецЕсли; 
	
КонецПроцедуры // ToArrayOfDelimiters()

Функция lx_GetTooken(Val TexT, Delimiters = " .,:;-_+=\/|&$#@()", Val Num = 0, AddDelims = False, ClearEmpty = True)	Экспорт

	Перем Tooken;

	ToArrayOfDelimiters(TexT, Delimiters, AddDelims, ClearEmpty);

	Tooken	= "";
	Num		= ?(Num = 0, ?(ПустаяСтрока(TexT), 0, StrLineCount(TexT)), Num);

	Если (Num <= ?(ПустаяСтрока(TexT), 0, StrLineCount(TexT))) Тогда

		Tooken	= TrimAll(StrGetLine(TexT, Num));

	КонецЕсли;

	Возврат (Tooken);

КонецФункции // lx_GetTooken()

Функция lx_NumTooken(Val TexT, Delimiters = " .,:;-_+=\/|&$#@()", ClearEmpty = True)	Экспорт

	ToArrayOfDelimiters(TexT, Delimiters,, ClearEmpty);

	Возврат ?(ПустаяСтрока(TexT), 0, StrLineCount(TexT));

КонецФункции // lx_NumTooken()

Функция lx_Explore(TexT, AddChar = " ")	Экспорт

	Explored	= AddChar;

	Для Position = 1 По StrLen(TexT) Цикл

		Explored	= Explored + Mid(TexT, Position, 1) + AddChar;

	КонецЦикла;

	Возврат (Explored);
КонецФункции // lx_Explore()

//	Заполнить коллекцию из строки с разделителями
Функция lx_FillValueList(VL = Undefined, Знач TexT, Mode = "array", Delimiters = " .,:;-_+=\/|&$#@()", DefoltSize = Undefined, ClearEmpty = True, TypeOf = Undefined)	Экспорт

	Если НРег(Mode) = "array" Тогда

		Если DefoltSize = Неопределено Тогда

			VL	= Новый Массив;

		Иначе

			VL	= Новый Массив(DefoltSize);

			Если НЕ TypeOf = Undefined Тогда

				Для Index = 0 По  DefoltSize - 1 Цикл

					VL[Index] = TypeOf.AdjustValue();

				КонецЦикла;

			КонецЕсли;

		КонецЕсли; 

		VLType	= 1;
		
	ИначеЕсли НРег(Mode) = "map" Тогда
		
		VL	= Новый Соответствие;
		VLType	= 2;

	Иначе

		VL		= Новый СписокЗначений;
		VLType	= 0;

	КонецЕсли;

	Если (ТипЗнч(TexT) = Тип("Строка")) Тогда
		
		NeedType = NOT TypeOf = Undefined;
		Count    = lx_NumTooken(TexT, Delimiters, ClearEmpty);

		Для Position = 1 По Count Цикл

			Value = lx_GetTooken(TexT, Delimiters, Position,, ClearEmpty);

			Если NeedType Тогда

				Value = TypeOf.ПривестиЗначение(Value);

				Если ТипЗнч(Value) = Тип("Строка") Тогда

					Value = TrimAll(Value);

				КонецЕсли;

			КонецЕсли;

			Если VLType = 1 Тогда

				УстановитьЗначениеВМассиве(VL, Position, Value, Истина);

			ИначеЕсли VLType = 2 Тогда

				VL.Вставить(Value, Истина);

			Иначе

				VL.Добавить(Value);

			КонецЕсли; 
			
		КонецЦикла;
		
	Иначе

		Если НЕ(TexT = Неопределено) Тогда

			Для каждого Value Из TexT Цикл

				Если ТипЗнч(Value) = Тип("КлючИЗначение") Тогда

						VL.Добавить(Value.Ключ, Value.Значение);	

				Иначе	VL.Добавить(Value);	

				КонецЕсли; 

			КонецЦикла;

		КонецЕсли; 

	КонецЕсли;
	
	Возврат (VL);

КонецФункции // lx_ValueList()

Функция lx_FirstSymbols(Знач TexT, Delimiters = " .,:;-_+=\/|&$#@()", ToUpper = False)	Экспорт

	ToArrayOfDelimiters(TexT, Delimiters,, Истина);
	FirstSymbols= "";
	Count		= StrLineCount(TexT);

	Для Position = 1 По Count Цикл

		FirstSymbols	= FirstSymbols + Left(TrimAll(StrGetLine(TexT, Position)), 1);

	КонецЦикла; 


	Возврат ?(ToUpper, Upper(FirstSymbols), FirstSymbols);

КонецФункции // КОНЕЦ lx_FirstSymbols()

Функция lx_GetKeyValue(Val Text, Delimiters = " .,:;-_+=\/|&$#@()")	Экспорт

	KeyValue	= Новый Структура(
		"Ключ,
		|Значение",
		TrimAll(lx_GetTooken(TexT, Delimiters, 1)),
		TrimAll(lx_GetTooken(TexT, Delimiters, 2)));

	Возврат KeyValue;

КонецФункции // КОНЕЦ lx_GetKeyValue()

Функция lx_ExistDelims(Val Text, Delimiters = " .,:;-_+=\/|&$#@()")	Экспорт

	OK     = False;
	Lenght = StrLen(Delimiters);	//	Количество разделителей.

	Для Position = 1 По Lenght Цикл

		Если НЕ Найти(Text, Mid(Delimiters, Position, 1)) = 0 Тогда

			OK = True;
			Прервать;

		КонецЕсли; 

	КонецЦикла;

	Возврат OK;

КонецФункции // lx_ExistDelims()

#КонецОбласти

Процедура УстановитьЗначениеВМассиве(Массив, Позиция, Значение, ПозицияОтЕдиницы = Ложь)	Экспорт

	Если ТипЗнч(Массив) = Тип("Массив") Тогда

		Position = Позиция + ?(ПозицияОтЕдиницы, 0, 1);

		Если Position > Массив.Количество() Тогда
			
			Массив.Добавить("");

		КонецЕсли; 

		Массив.Установить(Position - 1, Значение);

	КонецЕсли; 

КонецПроцедуры

Процедура УстановитьЗначениеЕслиОтличается(ИмяРеквизита, Знач ЗначениеРеквизита, Объект, ПроверятьЗначениеЗаполнено = Ложь)	Экспорт

	Если НЕ ПроверятьЗначениеЗаполнено ИЛИ ПроверятьЗначениеЗаполнено И ЗначениеЗаполнено(ЗначениеРеквизита) Тогда

		Если ТипЗнч(ЗначениеРеквизита) = Тип("Строка") Тогда

			ЗначениеРеквизита = СокрЛП(ЗначениеРеквизита);

		КонецЕсли;

		Если НЕ Объект[ИмяРеквизита] = ЗначениеРеквизита Тогда

			Объект[ИмяРеквизита] = ЗначениеРеквизита;

		КонецЕсли;

	КонецЕсли;

КонецПроцедуры

Процедура УстановитьЗначениеЕслиНеЗаполнено(ИмяРеквизита, ЗначениеРеквизита, Объект)	Экспорт

	Если НЕ ЗначениеЗаполнено(Объект[ИмяРеквизита]) Тогда

		Объект[ИмяРеквизита] = ЗначениеРеквизита;

	КонецЕсли;

КонецПроцедуры

Процедура ПроверитьСвойство(Ключ, Значение, СтруктураДанных)	Экспорт

	#Если Клиент Тогда
	//СтруктураДанных = Новый Структура;
	#КонецЕсли

	Если НЕ СтруктураДанных.Свойство(Ключ) Тогда

		СтруктураДанных.Вставить(Ключ, Значение);

	КонецЕсли;

КонецПроцедуры

//	LNK 14.08.2022 07:57:36
Процедура СвойствоУдалить(СтрокаКлючей, СтруктураДанных)	Экспорт

	#Если Клиент Тогда
	//СтруктураДанных = Новый Структура;
	#КонецЕсли

	Для каждого Ключ Из ОбщегоНазначенияКлиентСервер.lx_FillValueList(, СтрокаКлючей,, ",",,, Новый ОписаниеТипов("Строка")) Цикл

		СтруктураДанных.Удалить(Ключ);

	КонецЦикла;

КонецПроцедуры

#Если НЕ ТонкийКлиент Тогда
	
//	LNK 12.12.2021 06:03:03
Функция ОформитьСтруктуруТаблицы(Колонки)	Экспорт

	ТаблицаЗначений = Новый ТаблицаЗначений;

	Для каждого Колонка Из Колонки Цикл

		НоваяКолонка = ТаблицаЗначений.Колонки.Добавить(Колонка.Имя, Новый ОписаниеТипов(Колонка.ТипЗначения,, "NULL"));

	КонецЦикла;

	Возврат ТаблицаЗначений;

КонецФункции

#Область МетодыОтладочногоХарактера

//	LNK 02.12.2021 04:53:55 - отладочная группа методов.
Функция ДобавитьСтроку(Таблица, СтрокаИсточник = Неопределено)	Экспорт

	СтрокаТаблицы = Таблица.Добавить();

	Если НЕ СтрокаИсточник = Неопределено Тогда

		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, СтрокаИсточник);

	КонецЕсли;

	Возврат СтрокаТаблицы;

КонецФункции

//	LNK 05.01.2022 07:10:05 - отладочная группа методов.
Функция ОчиститьТаблицу(Таблица, Отборы = Неопределено)	Экспорт

	#Если Клиент Тогда
	//Таблица = Документы.ЧекККМ.СоздатьДокумент().СкидкиНаценки;
	#КонецЕсли

	Если Отборы = Неопределено Тогда

		Таблица.Очистить();

	Иначе

		СтрокиТаблицы = Таблица.НайтиСтроки(Отборы);

		Для каждого СтрокаТаблицы Из СтрокиТаблицы Цикл

			Таблица.Удалить(СтрокаТаблицы);

		КонецЦикла;

	КонецЕсли;

	Возврат Таблица.Количество();

КонецФункции

#КонецОбласти
	
#КонецЕсли

Функция СтрокаТаблицыКакСтруктура(Знач Колонки, СтрокаТаблицы = Неопределено, ОбязательнаяТипизация = Истина, СтруктураВозврата = Неопределено)	Экспорт

	Перем Значение;

	Если НЕ ТипЗнч(СтруктураВозврата) = Тип("Структура") Тогда

		СтруктураВозврата = Новый Структура;

	КонецЕсли;

	Если ТипЗнч(Колонки) = Тип("ТаблицаЗначений")	Тогда

		Колонки	= Колонки.Колонки;

	КонецЕсли;

	РаботаемСТабличнойЧастью = ТипЗнч(Колонки) = Тип("КоллекцияОбъектовМетаданных");

	Для каждого Колонка Из Колонки Цикл

		Попытка

			Если СтрокаТаблицы = Неопределено Тогда

				Если РаботаемСТабличнойЧастью Тогда

						МассивТипов = Колонка.Тип.Типы();

				Иначе	МассивТипов = Колонка.ТипЗначения.Типы();

				КонецЕсли;
				
				Если ОбязательнаяТипизация И МассивТипов.Количество() > 1 Тогда

					Для каждого ЭлементТипа Из МассивТипов Цикл

						Если  НЕ ЭлементТипа = Тип("Null")
							И НЕ ЭлементТипа = Тип("Неопределено") Тогда

							ОписаниеТипов = Новый ОписаниеТипов(AAD(ЭлементТипа));
							Значение      = ОписаниеТипов.ПривестиЗначение();
							Прервать;

						КонецЕсли;

					КонецЦикла;

				Иначе

					Если РаботаемСТабличнойЧастью Тогда

						Значение = Колонка.Тип.ПривестиЗначение();

					Иначе

						Значение = Колонка.ТипЗначения.ПривестиЗначение();

					КонецЕсли;

				КонецЕсли;

			Иначе	Значение = СтрокаТаблицы[Колонка.Имя];

			КонецЕсли;

			СтруктураВозврата.Вставить(Колонка.Имя, Значение);

		Исключение	КонецПопытки;

	КонецЦикла; 

	Возврат СтруктураВозврата;

КонецФункции

Функция ПолучитьСтруктуруЗаписиРегистра(ПолноеИмя)	Экспорт	//	LNK 04.05.2020 10:24:08

	Возврат ОбщегоНазначенияПовтИсп.ПолучитьСтруктуруЗаписиРегистра(ПолноеИмя);

КонецФункции

#Если НЕ ТонкийКлиент Тогда

//	LNK 05.05.2022 07:01:06
Функция ПолучитьТаблицуОбразРегистра(ПолноеИмя)	Экспорт	//	LNK 05.05.2022 07:01:12

	Возврат ОбщегоНазначенияПовтИсп.ПолучитьТаблицуОбразРегистра(ПолноеИмя);

КонецФункции
	
#КонецЕсли

Функция ПолучитьИтогТаблицы(ИмяРеквизита, ПараметрыОтбора, ТаблицаЗначений, СтрокиТаблицы = Неопределено)	Экспорт

	СуммаИтога    = 0;
	СтрокиТаблицы = ТаблицаЗначений.НайтиСтроки(ПараметрыОтбора);

	Для каждого СтрокаТаблицы Из СтрокиТаблицы Цикл

		СуммаИтога = СуммаИтога + СтрокаТаблицы[ИмяРеквизита];

	КонецЦикла;

	Возврат СуммаИтога;

КонецФункции

Функция ВРЕМЯ(Знач ДатаВремя = Неопределено, УказатьСекунды = Истина, ЧасовВСутках = 24, ПараметрКакЧасыВДесятичномПредставлении = Ложь)	Экспорт

	ПолныеСутки	= 86400;

	ДатаВремя	= ?(ДатаВремя = Неопределено, ТекущаяДата(), ДатаВремя);

	Если ТипЗнч(ДатаВремя) = Тип("Дата") Тогда

	//	Передана дата - следует вернуть количество секунд её состава "Время".
		ДатаВремя	= Час(ДатаВремя) * 3600 + Минута(ДатаВремя) * 60 + Секунда(ДатаВремя);

	ИначеЕсли ТипЗнч(ДатаВремя) = Тип("Строка") Тогда

		Если lx_ExistDelims(ДатаВремя) Тогда

			Массив    = lx_FillValueList(, ДатаВремя, "array",, 3);
			ДатаВремя = Мин(Число(Массив[0]) * 3600 + Число(Массив[1]) * 60 + Число(Массив[2]), ПолныеСутки);

		Иначе

			ДатаВремя = Мин(Число(Лев(ДатаВремя, 2)) * 3600 + Число(Сред(ДатаВремя, 3, 2)) * 60 + Число(Сред(ДатаВремя, 5, 2)), ПолныеСутки);

		КонецЕсли;

	ИначеЕсли ТипЗнч(ДатаВремя) = Тип("Число") Тогда
		
		Если ПараметрКакЧасыВДесятичномПредставлении Тогда

		//	Передано число - время в десятичном представлении (например, 1.5 = "полтора часа").
		//	Возвращаем текстовое представление "1 час 30 мин 40 сек" (если нужно указать секунды)
			Дни       = Цел(ДатаВремя / ЧасовВСутках);
			ДатаВремя = ДатаВремя - Дни * ЧасовВСутках;
			Часы      = Цел(ДатаВремя);
			Минуты    = ?(УказатьСекунды, Цел((ДатаВремя - Часы) * 60), Окр((ДатаВремя - Часы) * 60));
			Секунды   = Окр(((ДатаВремя - Часы) * 60 - Цел((ДатаВремя - Часы) * 60)) * 60);

			ДатаВремя = TrimAll(
					?(Дни > 0, Формат(Дни, "ЧГ=") + " дн. ", "")
				  + Формат(Часы, "ЧЦ=2; ЧН=00; ЧВН=") + " час. "
				  + Формат(Минуты, "ЧЦ=2; ЧН=00; ЧВН=") + " мин. "
				  + ?(УказатьСекунды, Формат(Секунды, "ЧЦ=2; ЧН=00; ЧВН=") + " сек.", ""));

		Иначе

		//	Передано число (количество секунд) - следует вернуть строковое представление времени
		//	(используется в различных информационных ситуациях - замеры выполнения и т.п.)
			ДатаВремя = Мин(ДатаВремя, ПолныеСутки);
			Часы	  = Цел(ДатаВремя / 3600);
			Минуты	  = Цел((ДатаВремя - Часы * 3600) / 60);
			Секунды	  = Цел((ДатаВремя - Часы * 3600 - Минуты * 60));

			ДатаВремя = Формат(Часы, "ЧЦ=2; ЧН=; ЧВН=") + ":" +
						Формат(Минуты, "ЧЦ=2; ЧН=; ЧВН=") + ?(УказатьСекунды, ":" +
						Формат(Секунды, "ЧЦ=2; ЧН=; ЧВН="), "");

		КонецЕсли;

	КонецЕсли; 

	Возврат ДатаВремя;

КонецФункции // ВРЕМЯ()

Функция СтрокаКакЧисло(ПараметрСтрока)	Экспорт

	ТипЧисло = Новый ОписаниеТипов("Число");

	Возврат ТипЧисло.ПривестиЗначение(ПараметрСтрока);

КонецФункции // СтрокаКакЧисло()

Функция АБС(Знач Аргумент) Экспорт
	
	Возврат Макс(Аргумент, -Аргумент);
	
КонецФункции

#Область РазличногоНазначения

Функция УникальныйИдентификаторВремя(Знач УникальныйИдентификатор)	Экспорт

	УникальныйИдентификатор = ВРег(СтрЗаменить(TrimAll(УникальныйИдентификатор), "-", ""));

	Если Сред(УникальныйИдентификатор, 13, 1) = "1" Тогда

		ВремяЗначение = Дата(1582, 10, 15)
			+ ЧислоИзШестнадцатеричнойСтроки(
				"0x" + ВРег(
					  Сред(УникальныйИдентификатор, 14, 3)
					+ Сред(УникальныйИдентификатор,  9, 4)
					+ Сред(УникальныйИдентификатор,  1, 8)
					)
			) / 10000000;

	Иначе

	//	Уникальный идентификатор такого вида не содержит информации о времени.
		ВремяЗначение = '00010101';

	КонецЕсли;
	
	Возврат ВремяЗначение;

КонецФункции // УникальныйИдентификаторВремя()

#Если Сервер Тогда

Функция РеквизитПеречисления(Значение, Реквизит = "имя", ЗначениеПоУмолчанию = "")		Экспорт

	Определение	= "";

	Если Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(Значение)) Тогда

		Если НЕ Значение.Пустая() Тогда

			Определение	= Значение.Метаданные().ЗначенияПеречисления[Перечисления[Значение.Метаданные().Имя].Индекс(Значение)][Реквизит];

		КонецЕсли; 

	КонецЕсли; 	

	Если ПустаяСтрока(Определение) И НЕ ПустаяСтрока(ЗначениеПоУмолчанию) Тогда

		Определение = ЗначениеПоУмолчанию;

	КонецЕсли;

	Возврат (Определение);

КонецФункции

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);

	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

//	LNK 20.07.2018 13:51:17
Функция ЗначениеПеречисления(Менеджер, Имя)	Экспорт

	Возврат ?(ПустаяСтрока(Имя), Менеджер.ПустаяСсылка(), Менеджер[Имя]);

КонецФункции

#КонецЕсли

Функция АтрибутТипаУказан(Атрибут, ТипЗначения)	Экспорт

	Возврат ТипЗнч(Атрибут)= ТипЗначения И ЗначениеЗаполнено(Атрибут);

КонецФункции // АтрибутТипаУказан()

#КонецОбласти

#КонецОбласти

//	LNK 18.11.2019 10:17:29
Функция СтруктураПредставление(КлючЭлемента, ЭлементДанных)	Экспорт

	Представление = "";

	СтруктураПредставлениеЗаполнить(КлючЭлемента, ЭлементДанных, 0, Представление);

	Возврат Представление;

КонецФункции

Процедура СтруктураПредставлениеЗаполнить(КлючЭлемента, ЭлементДанных, Отступ, Представление)

	Если НЕ ПустаяСтрока(КлючЭлемента) Тогда

		Представление = Представление + ?(ПустаяСтрока(Представление), "", Символы.ПС)
		+ ОбщегоНазначенияКлиентСервер.REPEAT(Символы.Таб, Отступ)
		+ КлючЭлемента;

	КонецЕсли;

	Если ТипЗнч(ЭлементДанных) = Тип("Строка") Тогда

		Представление = Представление + ": """ + ЭлементДанных + """";

	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("Дата") Тогда

		Представление = Представление + ": '" + ЭлементДанных + "'";

	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("Число") ИЛИ ТипЗнч(ЭлементДанных) = Тип("Булево") Тогда

		Представление = Представление + ": " + ЭлементДанных;

	ИначеЕсли ЭлементДанных = Неопределено Тогда

		Представление = Представление + ": Undefined";

	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("Структура") Тогда

		Для каждого КлючЗначение Из ЭлементДанных Цикл

			СтруктураПредставлениеЗаполнить(КлючЗначение.Ключ, КлючЗначение.Значение, Отступ + 1, Представление);

		КонецЦикла;

	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип("Массив") Тогда

		ИндексМассива = 0;
		Представление = Представление + " (массив элементов)";

		Для каждого ЭлементМассива Из ЭлементДанных Цикл

			СтруктураПредставлениеЗаполнить("" + ИндексМассива, ЭлементМассива, Отступ + 1, Представление);

			ИндексМассива = ИндексМассива + 1;

		КонецЦикла;

	Иначе

		Представление = Представление + ": " + СокрЛП(ЭлементДанных);

	КонецЕсли;

КонецПроцедуры

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Экспорт
	
	Если Условие <> Истина Тогда
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + " " + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'в %1'"), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

#Область СериализацияJSON

//	LNK 15.03.2018 10:03:58
Функция ДесериализоватьJSON(ДанныеJSON)	Экспорт

	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ДанныеJSON);

	ЗначениеJSON = СериализаторXDTO.ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();

	Возврат ЗначениеJSON;

КонецФункции // ДесериализоватьJSON()

//	LNK 15.03.2018 10:18:48
Функция СериализоватьJSON(ДанныеСериализации, Явное = Истина)	Экспорт

	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(, Символы.Таб));
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, ДанныеСериализации, ?(Явное, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));

	Возврат ЗаписьJSON.Закрыть();

КонецФункции // СериализоватьJSON()

#КонецОбласти

//	LNK 20.07.2018 09:48:40
Функция СсылкаПустая(ЛюбаяСсылка)	Экспорт

	ЗначениеНеЗаполнено = НЕ ЗначениеЗаполнено(ЛюбаяСсылка);

	Если НЕ ЗначениеНеЗаполнено Тогда

		СписокКритериев = Новый Массив;
		СписокКритериев.Добавить("<Object not found> (");
		СписокКритериев.Добавить("<Объект не найден> (");
		СписокКритериев.Добавить("<Об`єкт не знайдено> (");

		Представление = СокрЛП(ЛюбаяСсылка);

		Для каждого Литерал Из СписокКритериев Цикл

			Если Лев(Представление, СтрДлина(Литерал)) = Литерал Тогда

				ЗначениеНеЗаполнено = Истина;
				Прервать;

			КонецЕсли;

		КонецЦикла;

	КонецЕсли;

	Возврат ЗначениеНеЗаполнено;

КонецФункции

//	LNK 02.12.2019 13:52:52
Функция ДанныеРасчётаВнешнейСистемой(ДокументСсылка)	Экспорт

	ЗначениеДанных = ОбщегоНазначенияРТ.ПолучитьЗначениеХранилища(ДокументСсылка, "ДанныеРасчёта");

	Если ТипЗнч(ЗначениеДанных) = Тип("Структура") Тогда

			ДанныеПредставление = ОбщегоНазначенияКлиентСервер.СтруктураПредставление("Хранимые Данные", ЗначениеДанных);

	Иначе	ДанныеПредставление = "";

	КонецЕсли;

	Возврат ДанныеПредставление;

КонецФункции

//	LNK 05.07.2022 13:34:07	Служебная функция для выполнения некоторых процедур
Функция ВыполнитьКоманду(Команда, Пар1 = Неопределено, Пар2 = Неопределено, Пар3 = Неопределено, Пар4 = Неопределено, Пар5 = Неопределено)	Экспорт

	Выполнить(Команда);

	Возврат Истина;

КонецФункции


