
#Область ПрограммныйИнтерфейс

Процедура КафкаСообщения(ТипОбмена) Экспорт
	
	Если ВРег(ТипОбмена) = "ОТПРАВКА" Тогда
		
		КафкаВызовСервера.ОтправитьСообщения();
		
	ИначеЕсли ВРег(ТипОбмена) = "ПОЛУЧЕНИЕ" Тогда

		Запрос = Новый Запрос;
		Запрос.Текст =
			"ВЫБРАТЬ
			|	КаналыПолучения.Ссылка
			|ИЗ
			|	Справочник.КафкаКаналыПолучения КАК КаналыПолучения
			|ГДЕ
			|	НЕ КаналыПолучения.ПометкаУдаления";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			КафкаВызовСервера.ПолучитьСообщение(Выборка.Ссылка);
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

// Объект в строку JSON.
// 
// Параметры:
//  СсылкаНаЭлементВыгрузки - ЛюбаяСсылка
// 
// Возвращаемое значение:
//  Строка - Объект в строку JSON
Функция ОбъектВСтрокуJSON(СсылкаНаЭлементВыгрузки) Экспорт
	 
	Попытка
		ОбъектВыгрузки = СсылкаНаЭлементВыгрузки.ПолучитьОбъект();
	Исключение
		ОбъектВыгрузки = СсылкаНаЭлементВыгрузки;
	КонецПопытки;

	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(, Символы.Таб));
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, ОбъектВыгрузки, НазначениеТипаXML.Явное);

//	 ЗаписьJSON=Новый ЗаписьJSON;
//	 ЗаписьJSON.УстановитьСтроку();
//	 ЗаписатьJSON(ЗаписьJSON, Объект,, "ПреобразоватьJSON", КафкаСервер);
	 
	 Возврат ЗаписьJSON.Закрыть()
	 
 КонецФункции
 
// Объект в строку XML.
// 
// Параметры:
//  СсылкаНаЭлементВыгрузки - ЛюбаяСсылка - массив ссылок или ссылка 
//  ПравилаОбмена - Строка - Правила обмена
// 
// Возвращаемое значение:
//  Строка - Объект в строку XML
Функция ОбъектВСтрокуXML(СсылкаНаЭлементВыгрузки, ПравилаОбмена) Экспорт
	Обработка = Обработки.УниверсальныйОбменДаннымиXML.Создать();
	Обработка.РежимОбмена = "Выгрузка";
	Обработка.ВыводВОкноСообщенийИнформационныхСообщений = Истина;
	
	ИмяВременногоФайлаПравил = ПолучитьИмяВременногоФайла("xml");
	Текст = Новый ТекстовыйДокумент;
	Текст.ДобавитьСтроку(ПравилаОбмена);

	Текст.Записать(ИмяВременногоФайлаПравил);

	Обработка.ИмяФайлаПравилОбмена = ИмяВременногоФайлаПравил;
	Обработка.НеВыводитьНикакихИнформационныхСообщенийПользователю = Истина;
	ИмяВременногоФайлаОбмена = ПолучитьИмяВременногоФайла("xml");
	Обработка.ИмяФайлаОбмена = ИмяВременногоФайлаОбмена;
	Обработка.ЗагрузитьПравилаОбмена();
	
	Обработка.Параметры.ЭлементВыгрузки = СсылкаНаЭлементВыгрузки;

	Обработка.ВыполнитьВыгрузку();

	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ИмяВременногоФайлаОбмена);
	 
	Попытка
		УдалитьФайлы(ИмяВременногоФайлаПравил);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Кафка.ОбъектВСтрокуXML'"), УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайлаОбмена);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Кафка.ОбъектВСтрокуXML'"), УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат Текст.ПолучитьТекст(); 		 
 КонецФункции
 
// Отправить по каналу.
// 
// Параметры:
//  ОблачноеСобытие - Структура - Облачное событие
// 
// Возвращаемое значение:
//  Неопределено, Строка - Отправить по каналу
Функция ОтправитьПоКаналу(ОблачноеСобытие) Экспорт

	//мои люимые грязные хакИ
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
		
	ВотЧтоЖдетКафка = Новый Структура("records", Новый Массив);
	CloudEvent = СтруктураОблачногоСобытия(ОблачноеСобытие);
	ЗаписьСобытия = Новый Структура("value", CloudEvent);
	
	ВотЧтоЖдетКафка["records"].Добавить(ЗаписьСобытия);
	
	ЗаписатьJSON(ЗаписьJSON, ВотЧтоЖдетКафка);
	
	ВотЭтоМЫВПроксиИДолжныНаправить = ЗаписьJSON.Закрыть();
	
		
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/vnd.kafka.json.v2+json");
	
	Попытка
		ВозвращаемоеЗначение = КоннекторHTTP.Post(
	    		"http://" + Константы.АдресБрокераКафка.Получить() + ":8082/topics/" + ОблачноеСобытие.ИмяКаналаОтправки,
	    		ВотЭтоМЫВПроксиИДолжныНаправить, 
	    		Новый Структура("Заголовки", Заголовки)
			);
			
	    		
		Результат = КоннекторHTTP.КакJson(
			ВозвращаемоеЗначение
		);
		
		ЗаписьПолученногоСмещенияВКанале = Новый ЗаписьJSON;
		ЗаписьПолученногоСмещенияВКанале.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьПолученногоСмещенияВКанале, Результат["offsets"]);
		Результат = ЗаписьПолученногоСмещенияВКанале.Закрыть();
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(Результат);
		Результат = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();

	Исключение
		Результат = Неопределено;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'КАФКА. Отправка сообщения'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОписаниеОшибки());
			
	КонецПопытки;
	
	
	Возврат Результат;
	
КонецФункции
 
// Получить сообщения.
// 
// Параметры:
//  КаналПолучения Канал получения
// 
// Возвращаемое значение:
//  Булево - Получить сообщения
Функция ПолучитьСообщения(КаналПолучения) Экспорт

	ЗаписьУдачна = Истина;

	Попытка
		ЗаголовкиПодписки = Новый Соответствие;
		ЗаголовкиПодписки.Вставить("Content-Type", "application/vnd.kafka.json.v2+json");
		
		ПараметрыПотокаПодписчика = ПараметрыПодписки(СокрЛП(КаналПолучения.ИмяПодписчика));
		
		//региструем подписчика
		ВыданнаяПодписка = КоннекторHTTP.КакJson(
			КоннекторHTTP.Post(
				"http://" + Константы.АдресБрокераКафка.Получить() + ":8082/consumers/" + СокрЛП(КаналПолучения.ИмяПодписчика),
				ПараметрыПотокаПодписчика,
				Новый Структура("Заголовки", ЗаголовкиПодписки)
			)
		);
		
		//Docker DNS самый лучший
		БазовыйURL = СтрЗаменить(ВыданнаяПодписка["base_uri"], "http://rest-proxy:8082", "http://" + Константы.АдресБрокераКафка.Получить() + ":8082");
		
		//получаемподписку
		КоннекторHTTP.Post(
			БазовыйURL + "/subscription",КаналПодписки(СокрЛП(КаналПолучения.КаналПодписки)),Новый Структура("Заголовки", ЗаголовкиПодписки)
		);

		ЗаголовкиСериализацииЗаписей = Новый Соответствие;
		ЗаголовкиСериализацииЗаписей.Вставить("Accept", "application/vnd.kafka.json.v2+json");
		ЗаголовкиСериализацииЗаписей.Вставить("Content-Type", "application/vnd.kafka.json.v2+json");
		
		ПараметрыПреобразованияJSON = Новый Структура;
		ПараметрыПреобразованияJSON.Вставить("ПрочитатьВСоответствие", Ложь);

		ПараметрыЗапроса = Новый Структура;
		ПараметрыЗапроса.Вставить("timeout", "1000");

		//получаем записи
		ЗаписиПотока = КоннекторHTTP.КакJson(
			КоннекторHTTP.Get(БазовыйURL + "/records",ПараметрыЗапроса,Новый Структура("Заголовки", ЗаголовкиСериализацииЗаписей)),
			ПараметрыПреобразованияJSON);

		Для каждого _ЗаписьВПотоке из ЗаписиПотока Цикл
			Попытка
				ДанныеПотока = _ЗаписьВПотоке["value"];
				
				МенеджерЗаписи = РегистрыСведений.КафкаДанныеПотокаОбмена.СоздатьМенеджерЗаписи();
			
				МенеджерЗаписи.ВремяПолучения = ТекущаяУниверсальнаяДатаВМиллисекундах();
				МенеджерЗаписи.ПолученныеДанные = Новый ХранилищеЗначения(ДанныеПотока);
				МенеджерЗаписи.Записать();  
				
//				ДанныеДляФиксации = ДанныеФиксации(СокрЛП(КаналПолучения.КаналПодписки),
//					_ЗаписьВПотоке["partition"],
//					_ЗаписьВПотоке["offset"]);
//				КоннекторHTTP.Post(
//					БазовыйURL + "/offsets ", ДанныеДляФиксации, Новый Структура("Заголовки", ЗаголовкиПодписки)
//				);
			Исключение
				ЗаписьУдачна = Ложь;
				Прервать;
			КонецПопытки;
			
		КонецЦикла;

		Если ЗаписьУдачна Тогда
			КоннекторHTTP.Post(
				БазовыйURL + "/offsets",, Новый Структура("Заголовки", ЗаголовкиПодписки)
			);
		КонецЕсли;
		//удаляем коннект подписчика - если не удалить - будет обрущение REST PROXY на перебалансировке
		КоннекторHTTP.Delete(
			БазовыйURL,,Новый Структура("Заголовки", ЗаголовкиПодписки)
		);
	Исключение

		ЗаписьУдачна = Ложь;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'КАФКА. Получение сообщений'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ОписаниеОшибки());
			
	КонецПопытки;
	
	Возврат ЗаписьУдачна;
	
КонецФункции

// Запись справочника при записи.
// 
// Параметры:
//  Источник - СправочникОбъектИмяСправочника - Источник
//  Отказ - Булево - Отказ
Процедура ЗаписьСправочникаДокументаПриЗаписи(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка И Источник.ДополнительныеСвойства.Свойство("ЗагрузкаKafka") Тогда
		Возврат;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Источник);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);

	Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		ТипОтправки = "Справочник";
	ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		ТипОтправки = "Документ";
	Иначе
		Возврат;
	КонецЕсли;
	
	ИмяТипаОтправки = Источник.Метаданные().Имя;

	Запрос=Новый Запрос("ВЫБРАТЬ * ИЗ " + ТипОтправки + "." + ИмяТипаОтправки + " ГДЕ Ссылка=&Ссылка");
	Запрос.УстановитьПараметр("Ссылка", Источник.Ссылка);
	МассивВыгрузки = ОбщегоНазначения.ТаблицаЗначенийВМассив(Запрос.Выполнить().Выгрузить());
	СсылкаНаЭлементВыгрузки = МассивВыгрузки[0].Ссылка;

	ЗаписьВРегистрОтправки(ИмяТипаОтправки, СсылкаНаЭлементВыгрузки, ТипОтправки);
	
КонецПроцедуры

Процедура ЗаписьВРегистрОтправки(ИмяТипаОтправки, СсылкаНаЭлементВыгрузки, ТипОтправки)

	ЗапросКанала = Новый Запрос;
	ЗапросКанала.Текст = 
		"ВЫБРАТЬ
		|	КаналыОтправки.Ссылка,
		|	КаналыОтправки.ТипОтправки,
		|	КаналыОтправки.КаналОтправки,
		|	КаналыОтправки.ТипСобытия,
		|	КаналыОтправки.ТипСодержимого,
		|	КаналыОтправки.ПравилаОбмена,
		|	КаналыОтправки.ИмяТипаОтправки,
		|	КаналыОтправки.ПоШаблону,
		|	КаналыОтправки.ТекстЗапросаДляШаблона,
		|	КаналыОтправки.ПромежуточнаяЗапись
		|ИЗ
		|	Справочник.КафкаКаналыОтправки КАК КаналыОтправки
		|ГДЕ
		|	КаналыОтправки.ТипОтправки = &ТипОтправки
		|	И КаналыОтправки.ИмяТипаОтправки = &ИмяТипаОтправки";
	
	ЗапросКанала.УстановитьПараметр("ТипОтправки", ТипОтправки);
	ЗапросКанала.УстановитьПараметр("ИмяТипаОтправки", ИмяТипаОтправки);
	
	РезультатЗапроса = ЗапросКанала.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		МассивКаналовОтправки = Новый Массив();
		ВыборкаДанных = Неопределено;
		
		Если Выборка.ПоШаблону Тогда
			Если Не ПустаяСтрока(Выборка.ТекстЗапросаДляШаблона) Тогда
				
				Выполнить Выборка.ТекстЗапросаДляШаблона;

				Пока ВыборкаДанных.Следующий() Цикл
					МассивКаналовОтправки.Добавить(СтрЗаменить(Выборка.КаналОтправки, "%1", ВыборкаДанных.ТекстШаблона));
				КонецЦикла;
			Иначе
				Прервать;
			КонецЕсли;
		Иначе
			МассивКаналовОтправки.Добавить(Выборка.КаналОтправки);
		КонецЕсли;
		
		Если Выборка.ПромежуточнаяЗапись Тогда
			ДанныеДляОтправки = Выборка.ПравилаОбмена;
		Иначе
			Если Выборка.ТипСодержимого = Перечисления.КафкаТипСодержимого.application_json Тогда
				ДанныеДляОтправки = ОбъектВСтрокуJSON(СсылкаНаЭлементВыгрузки); 
			Иначе
				ДанныеДляОтправки = ОбъектВСтрокуXML(СсылкаНаЭлементВыгрузки, Выборка.ПравилаОбмена); 
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого ЭлементОправки Из МассивКаналовОтправки Цикл
			НомерЗаписи = Константы.НомерЗаписиКафка.Получить();
			Константы.НомерЗаписиКафка.Установить(НомерЗаписи + 1); 
			
			МенеджерЗаписи = РегистрыСведений.КафкаДанныеДляБрокераСообщений.СоздатьМенеджерЗаписи();
			
			МенеджерЗаписи.Канал = ЭлементОправки;
			МенеджерЗаписи.НомерЗаписи = НомерЗаписи;
			МенеджерЗаписи.ДанныеДляОтправки = ДанныеДляОтправки;
			МенеджерЗаписи.УИ = Новый УникальныйИдентификатор();
			МенеджерЗаписи.Тип = Выборка.ТипСобытия;
			МенеджерЗаписи.ОтметкаВремени = ДатуВTimestamp();
			МенеджерЗаписи.Представление = СсылкаНаЭлементВыгрузки;
			МенеджерЗаписи.ПромежуточнаяЗапись = Выборка.ПромежуточнаяЗапись;
			МенеджерЗаписи.СсылкаНаОбъект = СсылкаНаЭлементВыгрузки;
			МенеджерЗаписи.ТипСодержимого = Выборка.ТипСодержимого;
			МенеджерЗаписи.Записать();  
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаписьРегистраСведенийПриЗаписи(Источник, Отказ, Замещение) Экспорт
	
	Если Источник.ОбменДанными.Загрузка И Источник.ДополнительныеСвойства.Свойство("ЗагрузкаKafka") Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписьВРегистрОтправки(Источник.Метаданные().Имя, Источник, "РегистрСведений");

КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

 Функция ПреобразоватьJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт
	 
	 ТипЗначения=ТипЗнч(Значение);
	 
	 Если ТипЗначения=Тип("ТаблицаЗначений") Тогда
		 
		 //Для таблицы значений нужно обратное преобразование с рекурсией
		 ЗаписьJSON=Новый ЗаписьJSON;
		 ЗаписьJSON.УстановитьСтроку();
		 МассивСтрок=ОбщегоНазначения.ТаблицаЗначенийВМассив(Значение);
		 ЗаписатьJSON(ЗаписьJSON, МассивСтрок, , "ПреобразоватьJSON", );
		 ТекстJSON=ЗаписьJSON.Закрыть();
		 
		 //Преобразуем его обратно в типы 1С
		 ЧтениеJSON=Новый ЧтениеJSON;
		 ЧтениеJSON.УстановитьСтроку(ТекстJSON);
		 Возврат ПрочитатьJSON(ЧтениеJSON, Ложь);
		 
	 ИначеЕсли ТипЗначения=Тип("УникальныйИдентификатор") Тогда
		 Возврат СокрЛП(Значение);
	 КонецЕсли;
	 
	 МдОбъекта=Метаданные.НайтиПоТипу(ТипЗначения);
	 Если МдОбъекта=Неопределено Тогда
		 //Это объект простого типа, обработка не требуется
		 Возврат Значение;
	 КонецЕсли;
	 
	 Если Метаданные.Справочники.Содержит(МдОбъекта) Тогда
		 
		 СтрОбъекта=Новый Структура("Идентификатор,ИмяТипа", СокрЛП(Значение.УникальныйИдентификатор()),МдОбъекта.ПолноеИмя());
		 Если МдОбъекта.ДлинаКода>0 Тогда
			 СтрОбъекта.Вставить("Код", Значение.Код);
		 КонецЕсли;
		 Если МдОбъекта.ДлинаНаименования>0 Тогда
			 СтрОбъекта.Вставить("Наименование", Значение.Наименование);
		 КонецЕсли;
		 Если МдОбъекта.Иерархический>0 Тогда
			 СтрОбъекта.Вставить("Родитель", СокрЛП(Значение.Родитель.УникальныйИдентификатор()));
		 КонецЕсли;
		 Если МдОбъекта.Владельцы.Количество() и ЗначениеЗаполнено(Значение.Владелец) Тогда
			 СтрОбъекта.Вставить("Владелец", СокрЛП(Значение.Владелец.УникальныйИдентификатор()));
		 КонецЕсли;
		 Возврат СтрОбъекта;
		 
	 ИначеЕсли Метаданные.Документы.Содержит(МдОбъекта) Тогда
		 
		 Результат =  Новый Структура();
		 Результат.Вставить("Идентификатор", СокрЛП(Значение.УникальныйИдентификатор()));
		 Результат.Вставить("ИмяТипа", МдОбъекта.ПолноеИмя());
		 Результат.Вставить("Представление", СокрЛП(Значение));
		 Результат.Вставить("Дата", Значение.Дата);
		 Результат.Вставить("Номер", Значение.Номер);
		 Возврат Результат;
		 
	 ИначеЕсли Метаданные.Перечисления.Содержит(МдОбъекта) Тогда
		 //Перечисления в виде имён значений
		 Если Значение.Пустая() Тогда
			 Возврат "";
		 Иначе
			 Возврат ОбщегоНазначения.ИмяЗначенияПеречисления(Значение);
		 КонецЕсли;
	 КонецЕсли;
	 
	 //Строковое представление и всё
	 Возврат СокрЛП(Значение);
	 
 КонецФункции


#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция СтруктураОблачногоСобытия(ОблачноеСобытие)
	
	СхемаДанныхСамоеЛучшееЧтоЕсть =  ПолучитьобщийМакет("CloudEventSchemaExample").ПолучитьТекст();
	
	
	ЧтениеJSON = Новый ЧтениеJSON;	
	ЧтениеJSON.УстановитьСтроку(СхемаДанныхСамоеЛучшееЧтоЕсть);
	
	ВотЭтоЕдинаяСпецификация = 
		ПрочитатьJSON(ЧтениеJSON);
	
	//Если ОблачноеСобытие.ТипСодержимого = ОбщегоНазначения.ИмяЗначенияПеречисления(Перечисления.КафкаТипСодержимого.application_xml) Тогда
		ВотЭтоЕдинаяСпецификация["data"] = ОблачноеСобытие.Данные;
	//Иначе
	//	ЧтениеДанных = Новый ЧтениеJSON();
	//	ЧтениеДанных.УстановитьСтроку(ОблачноеСобытие.Данные);
	//	ВотЭтоЕдинаяСпецификация["data"] = ПрочитатьJSON(ЧтениеДанных);
	//КонецЕсли;
	
	//ЧтениеДанных = Новый ЧтениеJSON();
	//ЧтениеДанных.УстановитьСтроку(ОблачноеСобытие.Данные);
		
	ВотЭтоЕдинаяСпецификация["specversion"] = ОблачноеСобытие.ВерсияСпецификации;	
	ВотЭтоЕдинаяСпецификация["type"] = ОблачноеСобытие.Тип;
	ВотЭтоЕдинаяСпецификация["source"] = ОблачноеСобытие.Источник;
	ВотЭтоЕдинаяСпецификация["id"] = "" + ОблачноеСобытие.Идентификатор;
	ВотЭтоЕдинаяСпецификация["time"] = ОблачноеСобытие.ОтметкаВремени;
	ВотЭтоЕдинаяСпецификация["subject"] = ОблачноеСобытие.ПредметИсточника;
	ВотЭтоЕдинаяСпецификация["dataschema"] = ОблачноеСобытие.СхемаДанных;
	ВотЭтоЕдинаяСпецификация["datacontenttype"] = ОблачноеСобытие.ТипСодержимого;
	 
	
	Возврат ВотЭтоЕдинаяСпецификация;

	
КонецФункции

Функция ПараметрыПодписки(ИмяПодписичика, ФорматОжидаемогоСообщения = "json")
	
	//EnableAutoCommit
	ПараметрыЗапроса = Новый Структура();
	ПараметрыЗапроса.Вставить("name", ИмяПодписичика + "-id-" + новый УникальныйИдентификатор());
	ПараметрыЗапроса.Вставить("format", ФорматОжидаемогоСообщения);
	ПараметрыЗапроса.Вставить("auto_offset_reset", "earliest");
	ПараметрыЗапроса.Вставить("auto_commit_enable", "false");

	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПараметрыЗапроса);
	
	СтрПараметров = ЗаписьJSON.Закрыть();
	
	СтрПараметров = СтрЗаменить(СтрПараметров,"auto_offset_reset","auto.offset.reset");
	СтрПараметров = СтрЗаменить(СтрПараметров,"auto_commit_enable","auto.commit.enable");
	Возврат СтрПараметров;
	
КонецФункции

Функция КаналПодписки(ИмяКанала)
	
	//прикинь можно на несколько каналов подписаться ;-) в один поток.
	МассивКаналов = Новый Массив;
	МассивКаналов.Добавить(ИмяКанала);
	ПараметрыЗапроса = Новый Структура("topics", МассивКаналов);
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ПараметрыЗапроса);
	
	СтрПараметров = ЗаписьJSON.Закрыть();
	
	Возврат СтрПараметров;
	
КонецФункции

// Дату в timestamp.
// 
// Возвращаемое значение:
//  Число - Дату в timestamp
Функция ДатуВTimestamp()
	Возврат Формат(Число(ТекущаяДатаСеанса()-Дата("19700101")),"ЧН=0; ЧГ=0");
КонецФункции

Процедура ВыполнитьВБезопасномРежиме(Знач Алгоритм, Знач Параметры = Неопределено)
	
	УстановитьБезопасныйРежим(Истина);
	
	МассивРазделителей = РазделителиКонфигурации();
	
	Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
		
		УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		
	КонецЦикла;
	
	Выполнить (Алгоритм);
	
КонецПроцедуры

// Возвращает массив существующих в конфигурации разделителей.
//
// Возвращаемое значение: ФиксированныйМассив(Строка) - массив имен общих реквизитов, которые
//  являются разделителями.
//
Функция РазделителиКонфигурации()
	
	МассивРазделителей = Новый Массив;
	
	Для Каждого ОбщийРеквизит Из Метаданные.ОбщиеРеквизиты Цикл
		Если ОбщийРеквизит.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
			МассивРазделителей.Добавить(ОбщийРеквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый ФиксированныйМассив(МассивРазделителей);
	
КонецФункции

#КонецОбласти
