////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

//Возвращает результат запроса, определяющего набор элементов сегмента,
//из регистров сведений (применяется для не динамических сегментов)
//
Функция ВыборкаИзРегистра(СегментСсылка)
        	
		Запрос = Новый Запрос(
			"ВЫБРАТЬ
			|	НоменклатураСегмента.Номенклатура,
			|	НоменклатураСегмента.Характеристика
			|ИЗ
			|	РегистрСведений.НоменклатураСегмента КАК НоменклатураСегмента
			|ГДЕ
			|	НоменклатураСегмента.Сегмент = &Сегмент");
			
		Запрос.УстановитьПараметр("Сегмент", СегментСсылка);
		Возврат Запрос.Выполнить();

КонецФункции

//Возвращает таблицу значений, содержащую ссылки на элементы,
//входящие в сегмент, по настройкам СКД
//
Функция СписокЭлементовСКД(СегментСсылка)

	Настройки = ПолучитьНастройкиСписка(СегментСсылка);
	Возврат ТаблицаСКД(Настройки.СКД, Настройки.Настройки);

КонецФункции

//Возвращает структуру, содержащую СКД сегмента и настройки варианта,
//содержащего список элементов. При этом подключаются поля запроса списка.
//
Функция ПолучитьНастройкиСписка(СегментСсылка)
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	СегментыНоменклатуры.СхемаКомпоновкиДанных КАК СхемаКомпоновкиДанных
	|ИЗ
	|	Справочник.СегментыНоменклатуры КАК СегментыНоменклатуры
	|ГДЕ
	|	СегментыНоменклатуры.Ссылка = &Сегмент"
	);
	Запрос.УстановитьПараметр("Сегмент", СегментСсылка);
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст,"СегментыНоменклатуры",СегментСсылка.метаданные().Имя);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();

	СКД = Выборка.СхемаКомпоновкиДанных.Получить();

	Если СКД = Неопределено Тогда

		ВызватьИсключение "Настройки сегмента отсутствуют! Схема компоновки не определена.";

	КонецЕсли;

	//подключить поля запроса списка
	Поля = СКД.НаборыДанных.СписокСегмента.Поля;
	Для Каждого Поле Из Поля Цикл
		Поле.ОграничениеИспользования.Поле = Ложь;
	КонецЦикла;//подключить поля запроса списка

	НастройкиСписка = СКД.ВариантыНастроек.Список.Настройки;
	Настройки = СКД.НастройкиПоУмолчанию;
	ОбщегоНазначенияРТКлиентСервер.СкопироватьЭлементы(НастройкиСписка.ПараметрыДанных, Настройки.ПараметрыДанных);
	ОбщегоНазначенияРТКлиентСервер.СкопироватьЭлементы(НастройкиСписка.Отбор, Настройки.Отбор);

	Возврат Новый Структура("СКД, Настройки", СКД, НастройкиСписка);

КонецФункции

//Формирует и возвращает таблицу значений по СКД и настройкам
//Параметры:
//СКД - схема компоновки данных,
//Настройки - вариант настроек схемы, по которым необходимо сформировать таблицу
//
Функция ТаблицаСКД(СКД, Настройки)

	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(
		СКД,Настройки,,,
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений")
	);
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ТаблицаЗначений = Новый ТаблицаЗначений;
	ПроцессорВывода.УстановитьОбъект(ТаблицаЗначений);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);

	Колонка = ТаблицаЗначений.Колонки.Найти("Номенклатура");
	Если Колонка <> Неопределено Тогда
		Колонка.Имя = "ЭлементСписка";
	КонецЕсли;
	Колонка = ТаблицаЗначений.Колонки.Найти("Характеристика");
	Если Колонка <> Неопределено Тогда
		Колонка.Имя = "ХарактеристикаЭлемента";
	КонецЕсли;

	Если ТаблицаЗначений.Колонки.Количество() = 1 Тогда

			СтрокаИмён = "ЭлементСписка";

	Иначе	СтрокаИмён = "ЭлементСписка,ХарактеристикаЭлемента";

	КонецЕсли;

	ТаблицаЗначений.Свернуть(СтрокаИмён);

	Возврат ТаблицаЗначений;

КонецФункции

// Функция записывает значение в создаваемую запись XML
//
Функция ПолучитьXML(Значение) Экспорт
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(Запись, Значение);
	Возврат Запись.Закрыть();
	
КонецФункции

//	LNK 20.05.2019 13:18:50
Функция РазрешеноФормированиеНоменклатурыСегмента()	Экспорт

	Если НЕ ПривилегированныйРежим() Тогда

		УстановитьПривилегированныйРежим(Истина);

	КонецЕсли;

//	В центральном узле формирование будет выполняться в любом случае.. будет отличаться состав узлов для регистрации.
//	В периферийной ИБ вариант иной - либо разрешено, либо нет.
//	И регистрации в центральный узел, соответственно, не дожно быть.

	Если ОбменДаннымиПовтИсп.ЭтоГлавныйУзел() Тогда

		РазрешеноФормирование = Истина;

	Иначе

		Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	ЕСТЬNULL(ПолитикаМагазина.НоменклатуруСегментаФормироватьНаПериферии, Ведущая.НоменклатуруСегментаФормироватьНаПериферии) КАК НоменклатуруСегментаФормироватьНаПериферии,
		|	ВЫБОР
		|		КОГДА ПолитикаМагазина.Магазин = &Магазин
		|			ТОГДА 1
		|		ИНАЧЕ 0
		|	КОНЕЦ КАК КлючПорядка
		|ИЗ
		|	(ВЫБРАТЬ
		|		ЛОЖЬ КАК НоменклатуруСегментаФормироватьНаПериферии) КАК Ведущая
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.УчетнаяПолитикаМагазинов.СрезПоследних(
		|				,
		|				(Магазин = &Магазин
		|					ИЛИ Магазин = ЗНАЧЕНИЕ(Справочник.Магазины.ПустаяСсылка))
		|					И ЕСТЬNULL(ВЫРАЗИТЬ(&Магазин КАК Справочник.Магазины).СкладУправляющейСистемы, ЛОЖЬ) = ЛОЖЬ) КАК ПолитикаМагазина
		|		ПО (ИСТИНА)
		|
		|УПОРЯДОЧИТЬ ПО
		|	КлючПорядка УБЫВ"
		);
		Запрос.УстановитьПараметр("Магазин", ОбменДаннымиПовтИсп.ПолучитьДанныеУзла().Магазин);
		
		Выборка = Запрос.Выполнить().Выбрать();
		Выборка.Следующий();

		РазрешеноФормирование = Выборка.НоменклатуруСегментаФормироватьНаПериферии;

	КонецЕсли;

	Возврат РазрешеноФормирование;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ РЕГЛАМЕНТНЫХ ЗАДАНИЙ

//Выполняет формирование периодических сегментов
//
Процедура ВыполнитьПериодическоеФормирование() Экспорт

	Если НЕ ПривилегированныйРежим() Тогда

		УстановитьПривилегированныйРежим(Истина);

	КонецЕсли;

	ОбновитьПовторноИспользуемыеЗначения();

	Если НЕ СегментыСервер.РазрешеноФормированиеНоменклатурыСегмента() Тогда

		ВызватьИсключение "Отказано! Нет разрешения на формирование сегмента в этом узле.";

	КонецЕсли;

//	Выбрать сегменты, формируемые периодически
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	СегментыНоменклатуры.Ссылка КАК Ссылка,
	|	СегментыНоменклатуры.ДатаОбновления КАК КлючПорядка
	|ИЗ
	|	Справочник.СегментыНоменклатуры КАК СегментыНоменклатуры
	|ГДЕ
	|	СегментыНоменклатуры.СпособФормирования = ЗНАЧЕНИЕ(Перечисление.СпособыФормированияСегментов.ПериодическиОбновлять)
	|	И НЕ СегментыНоменклатуры.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	КлючПорядка"
	);
	Выборка = Запрос.Выполнить().Выбрать();

//	Сформировать выбранные сегменты
	Пока Выборка.Следующий() Цикл

		Параметры = Новый Массив;	//	LNK 18.08.2021 18:37:26
		Параметры.Добавить(Выборка.Ссылка);
		Параметры.Добавить(Перечисления.СпособыФормированияСегментов.ПериодическиОбновлять);
		Параметры.Добавить(Неопределено);
		Параметры.Добавить(Ложь);

		Попытка

			ФоновыеЗадания.Выполнить("СегментыСервер.СформироватьНоменклатуруСегмента"	//	LNK 18.08.2021 18:34:06
				, Параметры
				, СокрЛП(Выборка.Ссылка.УникальныйИдентификатор())
				, "Работаем сегмент: «" + Выборка.Ссылка + "»"
			);
			ОбщегоНазначенияКлиентСервер.Пауза(5000);	//	пауза 5 сек
		//	СформироватьНоменклатуруСегмента(Выборка.Ссылка, Перечисления.СпособыФормированияСегментов.ПериодическиОбновлять,, Ложь);

		Исключение

			ТекстОшибки = ОписаниеОшибки();
			ЗаписьЖурналаРегистрации("Сегменты.Формирование", УровеньЖурналаРегистрации.Ошибка
				, Метаданные.Справочники.СегментыНоменклатуры
				, Выборка.Ссылка
				, ТекстОшибки
			);

		КонецПопытки;

	КонецЦикла;

КонецПроцедуры

//Выполняет формирование периодических сегментов
//
Процедура ВыполнитьПериодическоеФормированиеГруппПолучателейСкидки() Экспорт

	УстановитьПривилегированныйРежим(Истина);

	//выбрать сегменты, формируемые периодически
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	ГруппыПолучателейСкидки.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ГруппыПолучателейСкидки КАК ГруппыПолучателейСкидки
	|ГДЕ
	|	ГруппыПолучателейСкидки.СпособФормирования = ЗНАЧЕНИЕ(Перечисление.СпособыФормированияСегментов.ПериодическиОбновлять)");
	Выборка = Запрос.Выполнить().Выбрать();

	//сформировать выбранные сегменты
	Пока Выборка.Следующий() Цикл
		СформироватьГруппуПолучателейСкидки(Выборка.Ссылка);
	КонецЦикла;

	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

//Выполняет очистку не динамических сегментов по запланированным датам
//
Процедура ВыполнитьПлановуюОчистку() Экспорт

	УстановитьПривилегированныйРежим(Истина);

	//выбрать сегменты, формируемые вручную с подходящей датой очистки
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	СегментыНоменклатуры.Ссылка
		|ИЗ
		|	Справочник.СегментыНоменклатуры КАК СегментыНоменклатуры
		|ГДЕ
		|	СегментыНоменклатуры.СпособФормирования = ЗНАЧЕНИЕ(Перечисление.СпособыФормированияСегментов.ФормироватьВручную)
		|	И СегментыНоменклатуры.ДатаОчистки <> ДАТАВРЕМЯ(1, 1, 1)
		|	И СегментыНоменклатуры.ДатаОчистки <= &ДатаОчистки");
	Запрос.УстановитьПараметр("ДатаОчистки", ТекущаяДатаСеанса());
	Выборка = Запрос.Выполнить().Выбрать();

	//очистить выбранные сегменты
	Пока Выборка.Следующий() Цикл
		Очистить(Выборка.Ссылка);
	КонецЦикла;

	УстановитьПривилегированныйРежим(Ложь);

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ФОРМИРОВАНИЯ И ОЧИСТКИ

Процедура УстановитьПолучателейСегмента(Получатели, СпособФормирования)	Экспорт

	Если ОбменДаннымиПовтИсп.ЭтоГлавныйУзел() Тогда

		Если СпособФормирования = Перечисления.СпособыФормированияСегментов.ФормироватьВручную Тогда

			ОбменДаннымиСервер.УстановитьВсехПолучателей(Получатели, "ПоМагазину");

		Иначе

			ОбменДаннымиСервер.УстановитьПолучателейМагазинов(Получатели, СегментыСерверПовтИсп.МагазиныФормированияСегментов(Ложь));

		КонецЕсли;

	Иначе

		Получатели.Очистить();

	КонецЕсли;

КонецПроцедуры

//	LNK 03.02.2017 08:33:18
//	Заполняет регистр сведений объектами, вошедшими в сегмент
Процедура СформироватьНоменклатуруСегмента(СегментСсылка, СпособФормирования = Неопределено, СписокЭлементов = Неопределено, ПроверятьРазрешение = Истина)	Экспорт

	Если ПроверятьРазрешение = Истина И НЕ ОбщегоНазначенияРТСервер.РазрешеноИзменениеВУзле(СегментСсылка, Ложь, Истина) Тогда

		ВызватьИсключение "Отказано! Формирование номенклатуры сегмента в узле ограничено.";

	КонецЕсли;

//	\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\/

	Если НЕ ПривилегированныйРежим() Тогда

		УстановитьПривилегированныйРежим(Истина);

	КонецЕсли;

	СегментОбъект = СегментСсылка.ПолучитьОбъект();	//	LNK 18.08.2021 18:25:44
	#Если _ Тогда
	СегментОбъект = Справочники.СегментыНоменклатуры.СоздатьЭлемент();
	#КонецЕсли

	СегментОбъект.Заблокировать();	//	LNK 18.08.2021 18:28:18

	Если СпособФормирования = Неопределено Тогда

		СпособФормирования = СегментОбъект.СпособФормирования;

	КонецЕсли;

	Если НЕ ТипЗнч(СписокЭлементов) = Тип("ТаблицаЗначений") Тогда

		СписокЭлементов = СписокЭлементовСКД(СегментСсылка);

	КонецЕсли;

	СтруктураОтбора = Новый Структура("Сегмент", СегментСсылка);

//	Подготовим таблицу для однозначности работы с набором записей.

	Колонка = СписокЭлементов.Колонки.Найти("Сегмент");

	Если Колонка = Неопределено Тогда

		СписокЭлементов.Колонки.Добавить("Сегмент", Новый ОписаниеТипов("СправочникСсылка.СегментыНоменклатуры"))

	КонецЕсли;

	СписокЭлементов.ЗаполнитьЗначения(СегментСсылка, "Сегмент");
	СтрокаИмён = "Сегмент";

	Колонка = СписокЭлементов.Колонки.Найти("ЭлементСписка");

	Если НЕ Колонка = Неопределено Тогда

		Колонка.Имя = "Номенклатура";
		СтруктураОтбора.Вставить(Колонка.Имя);
		СтрокаИмён  = СтрокаИмён + ?(ПустаяСтрока(СтрокаИмён), "", ",") + Колонка.Имя;

	ИначеЕсли НЕ СписокЭлементов.Колонки.Найти("Номенклатура") = Неопределено Тогда

		СтруктураОтбора.Вставить("Номенклатура");
		СтрокаИмён  = СтрокаИмён + ?(ПустаяСтрока(СтрокаИмён), "", ",") + "Номенклатура";

	КонецЕсли;

	Колонка = СписокЭлементов.Колонки.Найти("ХарактеристикаЭлемента");

	Если НЕ Колонка = Неопределено Тогда

			Колонка.Имя = "Характеристика";
			ВключатьХарактеристики = Истина;
			СтруктураОтбора.Вставить(Колонка.Имя);
			СтрокаИмён  = СтрокаИмён + ?(ПустаяСтрока(СтрокаИмён), "", ",") + Колонка.Имя;

	Иначе	ВключатьХарактеристики = Ложь;

	КонецЕсли;

	СписокЭлементов.Индексы.Добавить(СтрокаИмён);

//	Работаем переборами для экономии расхода памяти - могут быть очень большие таблицы.

	НаборТекущий = РегистрыСведений.НоменклатураСегмента.СоздатьНаборЗаписей();
	НаборТекущий.Отбор.Сегмент.Установить(СегментСсылка);
	НаборТекущий.Прочитать();

	НаборРабочий = РегистрыСведений.НоменклатураСегмента.СоздатьНаборЗаписей();
	НаборРабочий.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов", Истина);
	НаборРабочий.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения"  , Истина);
	НаборРабочий.ОбменДанными.Загрузка = Истина;
	НаборРабочий.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;

	СегментыСервер.УстановитьПолучателейСегмента(НаборРабочий.ОбменДанными.Получатели, СпособФормирования);	//	LNK 20.05.2019 15:19:41

//	Идём по набору записей и выясняем, есть ли в новой таблице такая запись? Если записи
//	с отбором по Номенклатуре и Характеристике нет - убиваем её в регистре.

	Счётчик = 0;	//	LNK 24.06.2022 07:36:31

	Для каждого ЗаписьНабора Из НаборТекущий Цикл

		ЗаполнитьЗначенияСвойств(СтруктураОтбора, ЗаписьНабора);
		СтрокиЭлементов = СписокЭлементов.НайтиСтроки(СтруктураОтбора);

		Если СтрокиЭлементов.Количество() = 0 Тогда

		//	Нет такой коллекции в новом составе сегмента! Нужно его удалить из регистра сегментов.
			НаборРабочий.Очистить();	//	на всякий случай
			УстановитьЗначенияОтбора(НаборРабочий.Отбор, СтруктураОтбора);
			НаборРабочий.Записать();	//	очищаем "физический" набор записей

			Счётчик = Счётчик + 1;	//	фиксируем в счётчике только очистку - в "живом" наборе этих регистраций не будет!

		КонецЕсли;

	КонецЦикла;

//	Теперь займёмся перебором таблицы нового состава сегмента.
//	Существующий набор записей опять перечитаем, чтобы получить его обновлённые данные с учётом
//	предыдущей очистки лишних записей. Выгрузим его в таблицу для поиска, которую проиндексируем.
	НаборТекущий.Прочитать();
	ТаблицаНабора = НаборТекущий.Выгрузить();
	ТаблицаНабора.Индексы.Добавить(СтрокаИмён);

	Для каждого СтрокаЭлемента Из СписокЭлементов Цикл

		ЗаполнитьЗначенияСвойств(СтруктураОтбора, СтрокаЭлемента);
		СтрокиНабора = ТаблицаНабора.НайтиСтроки(СтруктураОтбора);

	//	Если нужная запись уже есть, так зачем её переписывать?
	//	Лишняя регистрация на периферию будет.

		Если СтрокиНабора.Количество() = 0 Тогда

		//	Нет такой коллекции в старом составе набора записей!
		//	Выполняем обновление номенклатуры сегмента.
			НаборРабочий.Очистить();	//	на всякий случай
			УстановитьЗначенияОтбора(НаборРабочий.Отбор, СтруктураОтбора);
			УстановитьЗначенияЗаписи(НаборРабочий.Добавить(), СтруктураОтбора);
			НаборРабочий.Записать();	//	изменяем/добавляем "физический" набор записей

			Счётчик = Счётчик + 1;	//	а здесь фиксируем новые записи

		КонецЕсли;

	КонецЦикла;

//	.. и снова читаем существующий набор записей - нужно узнать, не пустой ли он случаем?.
	НаборТекущий.Прочитать();

	СегментОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов", Истина);
	СегментОбъект.ОбменДанными.Загрузка = Истина;

	СегментыСервер.УстановитьПолучателейСегмента(СегментОбъект.ОбменДанными.Получатели, СпособФормирования);	//	LNK 20.05.2019 15:19:41

	СегментОбъект.ДатаОбновления = ТекущаяДатаСеанса();

	Если НаборТекущий.Количество() = 0 Тогда

		СегментОбъект.ДатаОчистки = ТекущаяДатаСеанса();

	КонецЕсли;

	СегментОбъект.Записать();
	СегментОбъект.Разблокировать();	//	LNK 18.08.2021 18:28:18

//	LNK 24.06.2022 07:44:55
	ЖурналСобытий.Регистрация("НОМ.СЕГМЕНТА." + ОбщегоНазначенияКлиентСервер.РеквизитПеречисления(СпособФормирования,, "undef")
		, УровеньЖурналаРегистрации.Предупреждение
		, Метаданные.Справочники.СегментыНоменклатуры
		, СегментОбъект.Ссылка
		,
		, "Изменено " + Формат(Счётчик, "ЧН=0; ЧГ=") + " записей" + Символы.ПС
		+ "Размер набора: " + Формат(НаборТекущий.Количество(), "ЧН=0; ЧГ=") + " записей"
		, СокрЛП(СегментОбъект.Код) + " : " + СокрЛП(СегментОбъект.Наименование)
		, Ложь
		, Ложь
	);

КонецПроцедуры

//	LNK 10.04.2018 10:50:19
Процедура УстановитьЗначенияОтбора(Отбор, СтруктураОтбора)

	Для каждого КлючЗначение Из СтруктураОтбора Цикл

		Отбор[КлючЗначение.Ключ].Установить(КлючЗначение.Значение);

	КонецЦикла;

КонецПроцедуры

//	LNK 10.04.2018 10:57:22
Процедура УстановитьЗначенияЗаписи(ЗаписьНабора, СтруктураОтбора)

	Для каждого КлючЗначение Из СтруктураОтбора Цикл

		ЗаписьНабора[КлючЗначение.Ключ] = КлючЗначение.Значение;

	КонецЦикла;

КонецПроцедуры

//Заполняет регистр сведений объектами, вошедшими в сегмент
Процедура СформироватьГруппуПолучателейСкидки(ГруппаСсылка) Экспорт

	ПР = ПривилегированныйРежим();
	Если НЕ ПР Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;

	СписокЭлементов = СписокЭлементовСКД(ГруппаСсылка);
    	
	НаборЗаписей = РегистрыСведений.СоставГруппПолучателейСкидки.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ГруппаПолучателейСкидки.Установить(ГруппаСсылка);
	Для Каждого Элемент Из СписокЭлементов Цикл
		Запись = НаборЗаписей.Добавить();
		Запись.ГруппаПолучателейСкидки = ГруппаСсылка;
		Запись.Получатель = Элемент.ЭлементСписка;
	КонецЦикла;
	НаборЗаписей.Записать();
	
	Если НЕ ПР Тогда
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;

КонецПроцедуры

//	Удаляет из регистра сведений записи, относящиеся к сегменту
Процедура Очистить(СегментСсылка) Экспорт

	НаборСегмента = РегистрыСведений.НоменклатураСегмента.СоздатьНаборЗаписей();
	НаборСегмента.Отбор.Сегмент.Установить(СегментСсылка);
	НаборСегмента.Записать();

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБРАБОТКИ СХЕМЫ КОМПОНОВКИ

//Возвращает схему компоновки данных сегмента с учетом способа формирования сегмента
//
Функция ПолучитьСКД(СегментСсылка) Экспорт

	СКД = СегментСсылка.СхемаКомпоновкиДанных.Получить();

	Если СегментСсылка.СпособФормирования <>
		 Перечисления.СпособыФормированияСегментов.ФормироватьДинамически Тогда

		НаборСписка = СКД.НаборыДанных.Найти("СписокСегмента");

		//заменить запрос списка на обращение к регистру
		
		НаборСписка.Запрос = 
		"ВЫБРАТЬ
		|	НоменклатураСегмента.Номенклатура КАК ЭлементСписка,
		|	НоменклатураСегмента.Характеристика КАК ХарактеристикаЭлемента,
		|	НоменклатураСегмента.Сегмент
		|ИЗ
		|	РегистрСведений.НоменклатураСегмента КАК НоменклатураСегмента";
		
		
		//удалить отбор, соответствующий старому запросу
		ЭлементыОтбора = СКД.НастройкиПоУмолчанию.Отбор.Элементы;
		ЭлементыОтбора.Очистить();

		//добавить отбор по сегменту
		ОбщегоНазначенияРТКлиентСервер.ДобавитьОтбор(
			СКД.НастройкиПоУмолчанию, Новый ПолеКомпоновкиДанных("Сегмент"), СегментСсылка
		);

		//включить автозаполнение полей
		СКД.НаборыДанных.СписокСегмента.АвтоЗаполнениеДоступныхПолей = Истина;

	КонецЕсли;

	Возврат(СКД);

КонецФункции

//Возвращает схему компоновки данных сегмента с учетом способа формирования сегмента
//
Функция ПолучитьСКДГруппыПолучателейСкидки(ГруппаСсылка) Экспорт
	
	СКДСсылка = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ГруппаСсылка, "СхемаКомпоновкиДанных");
	СКД = СКДСсылка.Получить();

	Если ГруппаСсылка.СпособФормирования <> Перечисления.СпособыФормированияСегментов.ФормироватьДинамически Тогда

		НаборСписка = СКД.НаборыДанных.Найти("СписокСегмента");

		//заменить запрос списка на обращение к регистру
		
		НаборСписка.Запрос = 
		"ВЫБРАТЬ
		|	СоставГрупп.ГруппаПолучателейСкидки КАК ГруппаПолучателейСкидки,
		|	СоставГрупп.Получатель КАК ЭлементСписка
		|ИЗ
		|	РегистрСведений.СоставГруппПолучателейСкидки КАК СоставГрупп";
		
		
		//удалить отбор, соответствующий старому запросу
		ЭлементыОтбора = СКД.НастройкиПоУмолчанию.Отбор.Элементы;
		ЭлементыОтбора.Очистить();

		//добавить отбор по сегменту
		ОбщегоНазначенияРТКлиентСервер.ДобавитьОтбор(СКД.НастройкиПоУмолчанию, Новый ПолеКомпоновкиДанных("ГруппаПолучателейСкидки"), ГруппаСсылка);

		//включить автозаполнение полей
		СКД.НаборыДанных.СписокСегмента.АвтоЗаполнениеДоступныхПолей = Истина;

	КонецЕсли;

	Возврат(СКД);

КонецФункции

//Сохраняет схему компоновки данных сегмента в новое хранилище значения
//
Функция СохранитьСКД(ДанныеФормыОбъект, СхемаКомпоновки) Экспорт

	ДанныеФормыОбъект.СхемаКомпоновкиДанных = Новый ХранилищеЗначения(СхемаКомпоновки);
	ДанныеФормыОбъект.Записать();
	Возврат ДанныеФормыОбъект;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ОБРАБОТКИ НАБОРА ЭЛЕМЕНТОВ

//Возвращает список значений, содержащий элементы, входящие в сегмент,
//с учетом способа формирования сегмента
//
Функция СписокЗначений(СегментСсылка) Экспорт

	Список = Новый СписокЗначений();
	Список.ЗагрузитьЗначения(ТаблицаЗначений(СегментСсылка).ВыгрузитьКолонку(0));
	Возврат Список;

КонецФункции

//Возвращает таблицу значений, содержащую элементы, входящие в сегмент,
//с учетом способа формирования сегмента
//
Функция ТаблицаЗначений(СегментСсылка) Экспорт

	Если СегментСсылка.СпособФормирования =
		Перечисления.СпособыФормированияСегментов.ФормироватьДинамически Тогда
		Возврат СписокЭлементовСКД(СегментСсылка);
	Иначе
		Возврат ВыборкаИзРегистра(СегментСсылка).Выгрузить();
	КонецЕсли;

КонецФункции

//Возвращает массив элементов, входящих в сегмент,
//с учетом способа формирования сегмента
//
Функция МассивЭлементов(СегментСсылка) Экспорт

	Возврат ТаблицаЗначений(СегментСсылка).ВыгрузитьКолонку(0);

КонецФункции

//Возвращает количество объектов, отнесенных к сегменту,
//с учетом способа формирования сегмента
//
Функция КоличествоЭлементов(СегментСсылка) Экспорт

	Если СегментСсылка.СпособФормирования =
		Перечисления.СпособыФормированияСегментов.ФормироватьДинамически Тогда
		Возврат СписокЭлементовСКД(СегментСсылка).Количество();
	Иначе
		Выборка = ВыборкаИзРегистра(СегментСсылка);
		Если Выборка.Пустой() Тогда
			Возврат 0;
		Иначе
			Возврат Выборка.Выбрать().Количество();
		КонецЕсли;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

//Возвращает флаг вхождения объекта в сегмент
//Параметры:
//ОбъектСсылка - ссылка на анализируемый объект - номенклатуру,
//СегментСсылка - ссылка на сегмент номенклатуры,
//ХарактеристикаОбъекта - характеристика номенклатуры,
//Динамический - способ формирования сегмента - ФормироватьДинамически
Функция ВходитВСегмент(ОбъектСсылка, СегментСсылка, Характеристика = Неопределено, Динамический = Истина) Экспорт
	
	Если Динамический Тогда
		
		Настройки = ПолучитьНастройкиСписка(СегментСсылка);
		
		//установить отбор списка
		ЭлементОтбора = Настройки.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбора.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ЭлементСписка");
		ЭлементОтбора.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
		ЭлементОтбора.ПравоеЗначение = ОбъектСсылка;
		ЭлементОтбора.Использование  = Истина;
		
		Если Характеристика <> Неопределено Тогда
			ЭлементОтбора = Настройки.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ХарактеристикаЭлемента");
			ЭлементОтбора.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
			ЭлементОтбора.ПравоеЗначение = Характеристика;
			ЭлементОтбора.Использование  = Истина;
		КонецЕСли;
		
		Возврат ТаблицаСКД(Настройки.СКД, Настройки.Настройки).Количество() > 0;
		
	Иначе
		
		Запрос = Новый Запрос;
		
		Если ТипЗнч(ОбъектСсылка) = Тип("СправочникСсылка.Номенклатура") Тогда
			
			Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
			               |	НоменклатураСегмента.Номенклатура
			               |ИЗ
			               |	РегистрСведений.НоменклатураСегмента КАК НоменклатураСегмента
			               |ГДЕ
			               |	НоменклатураСегмента.Сегмент = &СегментСсылка
			               |	И НоменклатураСегмента.Номенклатура = &ОбъектСсылка
			               |	И НоменклатураСегмента.Характеристика = &Характеристика";
			
							
		Иначе
			
			Возврат Неопределено;
			
		КонецЕсли; 		
		
		Запрос.УстановитьПараметр("ОбъектСсылка",ОбъектСсылка);
		Запрос.УстановитьПараметр("СегментСсылка",СегментСсылка);
		Запрос.УстановитьПараметр("Характеристика",Характеристика);
		
		Возврат НЕ Запрос.Выполнить().Пустой();
		
	КонецЕсли;
	
КонецФункции

//Возвращает таблицу значений, содержащую ссылки на сегменты, в которые входит объект
//Параметры:
//ОбъектСсылка - ссылка на номенклатуру
//ВключатьДинамические - если истина, то с учетом динамических сегментов
//
Функция СписокСегментов(ОбъектСсылка, ВключатьДинамические = Ложь) Экспорт
	
	//выбрать не динамические сегменты, в которые входит номенклатура
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	НоменклатураСегмента.Сегмент
	|ИЗ
	|	РегистрСведений.НоменклатураСегмента КАК НоменклатураСегмента
	|ГДЕ
	|	НоменклатураСегмента.Номенклатура = &Номенклатура"
	);
	Запрос.УстановитьПараметр("Номенклатура", ОбъектСсылка);
	Результат = Запрос.Выполнить().Выгрузить();
	
	//добавить в результат динамические сегменты, в которые входит номенклатура
	Если ВключатьДинамические Тогда
		Запрос = Новый Запрос("ВЫБРАТЬ
		|	СегментыНоменклатуры.Ссылка
		|ИЗ
		|	Справочник.СегментыНоменклатуры КАК СегментыНоменклатуры
		|ГДЕ
		|	СегментыНоменклатуры.СпособФормирования = ЗНАЧЕНИЕ(Перечисление.СпособыФормированияСегментов.ФормироватьДинамически)");
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Если ВходитВСегмент(ОбъектСсылка, Выборка.Ссылка) Тогда
				Запись = Результат.Добавить();
				Запись.Сегмент = Выборка.Ссылка;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; //добавить в результат динамические сегменты, в которые входит номенклатура
	
	Возврат Результат;

КонецФункции

//Если в настройках СКД включено использование отбора по сегменту номенклатуры,
//то процедура устанавливает служебный параметр использования отбора по сегменту номенклатуры
//
//	Параметры:
//		КомпоновщикНастроек - КомпоновщикНастроекКомпоновкиДанных - компоновщик настроек СКД
//		
Процедура ВключитьОтборПоСегментуНоменклатурыВСКД(КомпоновщикНастроек) Экспорт
	
	ПараметрИспользуетсяОтборПоСегменту  = ОбщегоНазначенияРТКлиентСервер.ПолучитьПараметр(
		КомпоновщикНастроек.Настройки, 
		"ИспользуетсяОтборПоСегментуНоменклатуры"
	);
	
	Если ПараметрИспользуетсяОтборПоСегменту = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрИспользуетсяОтборПоСегменту.Значение      = Ложь;
	ПараметрИспользуетсяОтборПоСегменту.Использование = Ложь;
	
	НастройкиОсновнойСхемы = КомпоновщикНастроек.ПолучитьНастройки();
	
	ЭлементыОтбора = ОбщегоНазначенияКлиентСервер.НайтиЭлементыИГруппыОтбора(НастройкиОсновнойСхемы.Отбор,"СегментНоменклатуры");
	
	ИспользуетсяОтборПоСегменту = Ложь;
	
	Для каждого ЭлементОтбора из ЭлементыОтбора Цикл
		Если ЭлементОтбора.Использование Тогда  
			ИспользуетсяОтборПоСегменту = Истина;
		КонецЕсли;
		Прервать;
	КонецЦикла;
	
	ПараметрИспользуетсяОтборПоСегменту  = ОбщегоНазначенияРТКлиентСервер.ПолучитьПараметр(
		КомпоновщикНастроек.ФиксированныеНастройки, 
		"ИспользуетсяОтборПоСегментуНоменклатуры"
	);
	
	ПараметрИспользуетсяОтборПоСегменту.Значение = Истина;
	ПараметрИспользуетсяОтборПоСегменту.Использование = ИспользуетсяОтборПоСегменту;
	
КонецПроцедуры
