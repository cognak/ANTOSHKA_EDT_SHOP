Функция ВременныйПароль(РазделяемыйСекрет = "xAnТОn", НекоеЗначение = Неопределено)	Экспорт

	Если ТипЗнч(НекоеЗначение) = Тип("Дата") Тогда

		ЧисловоеЗначение = НекоеЗначение - НачалоГода(НекоеЗначение);	//	секунд с начала года

	ИначеЕсли ТипЗнч(НекоеЗначение) = Тип("Число") Тогда

		ЧисловоеЗначение = НекоеЗначение;

	Иначе

		ЧисловоеЗначение = НачалоЧаса(ТекущаяДата()) - НачалоГода(ТекущаяДата());

	КонецЕсли;

	HMA1 = Новый ХешированиеДанных(ХешФункция.SHA1);
	HMA1.Добавить(РазделяемыйСекрет + Формат(ЧисловоеЗначение, "ЧДЦ=; ЧН=0; ЧГ="));

	СписокЛексем = ОбщегоНазначенияКлиентСервер.lx_FillValueList(, СокрЛП(HMA1.ХешСумма),, " ", 20);

//	Значения ключа "Регистр":
//	0 - ВРег
//	1 - НРег
//	2 - ТРег

	Позиции = Новый Массив;
	Позиции.Добавить(Новый Структура("Индекс, Регистр",  5, 1));
	Позиции.Добавить(Новый Структура("Индекс, Регистр", 17, 0));
	Позиции.Добавить(Новый Структура("Индекс, Регистр",  1, 2));
	Позиции.Добавить(Новый Структура("Индекс, Регистр", 11, 0));

	TOTP = "";

	Для каждого Элемент Из Позиции Цикл

		Лексема = СписокЛексем[Элемент.Индекс];

		Если Элемент.Регистр = 0 Тогда
			
			Лексема = ВРег(Лексема);

		ИначеЕсли Элемент.Регистр = 1 Тогда
			
			Лексема = НРег(Лексема);

		Иначе
			
			Лексема = ТРег(Лексема);

		КонецЕсли;

		TOTP = TOTP + Лексема;

	КонецЦикла;

	Возврат TOTP;

КонецФункции

#Область ПроцедурыШифрованияСтроки	//	LNK 22.01.2020 07:21:07

//	Шифровка по методике Виженера.
//	---------------------------------------------------------------------------------------------------------------------
//	Неторые нюансы:
//	*	Ключ для шифрования формируется на основании пароля, длина ключа шифрования равна длине шифруемого текста
//	*	Код каждого символа ключа шифрования равен коду соответсвующего символа пароля, смещенного на псевдо случайную величину А
//	*	Псевдо случайная величина А зависит от максимального кода среди символов пароля и длины кодируемой строки
//	*	Код каждого символа зашифрованной строки равен сумме кода соответствующего символа исходной строки,
//		кода соответствующего символа ключа шифрования и псевдо-случайной величины В
//	*	Псевдо случайная величина В зависит от максимального кода среди символов ключа шифрования и длины кодируемой строки

Функция ПолучитьКлючШифрования(КлючевоеСлово, ДлинаКодируемойСтроки)	Экспорт
	
	ДлинаКлюча     = СтрДлина(КлючевоеСлово);
	КлючШифрования = "";
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(ДлинаКлюча);
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;

	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);

	СчетчикПоПаролю = Неопределено;

	Для Счетчик = 1 По ДлинаКодируемойСтроки Цикл
		
		Если (СчетчикПоПаролю = Неопределено) ИЛИ (СчетчикПоПаролю > ДлинаКлюча) Тогда
			
			СчетчикПоПаролю = 1;
				
		КонецЕсли;

		СлучайноеСмещение = ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);

		СимволПароля = Сред(КлючевоеСлово, СчетчикПоПаролю, 1);

		КлючШифрования = КлючШифрования + Символ(КодСимвола(СимволПароля) + СлучайноеСмещение);

		СчетчикПоПаролю = СчетчикПоПаролю + 1;

	КонецЦикла;

	Возврат КлючШифрования;

КонецФункции

Функция ЗашифроватьСтроку(КодируемаяСтрока, КлючШифрования)	Экспорт

	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);

	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);

	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;

	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);

	ЗакодированнаяСтрока = "";

	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл

		КодСимволаИсходнойСтроки  = КодСимвола(КодируемаяСтрока, Счетчик);
		КодСимволаКлючаШифрования = КодСимвола(КлючШифрования, Счетчик);		
		СлучайнаяСоставляющая     = ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);

		КодЗакодированныгоСимвола = КодСимволаИсходнойСтроки + КодСимволаКлючаШифрования + СлучайнаяСоставляющая;

		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодЗакодированныгоСимвола);

	КонецЦикла;

	Возврат ЗакодированнаяСтрока;
	
КонецФункции

Функция РасшифроватьСтроку(КодированнаяСтрока, КлючШифрования)	Экспорт
	
	ДлинаКодированнойСтроки = СтрДлина(КодированнаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодированнойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ВосстановленнаяСтрока = "";
	
	Для Счетчик = 1 ПО ДлинаКодированнойСтроки Цикл
		
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);			
		КодЗакодированныгоСимвола 	= КодСимвола(КодированнаяСтрока, Счетчик);
		СлучайнаяСоставляющая 		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодСимволаИсходнойСтроки = КодЗакодированныгоСимвола - КодСимволаКлючаШифрования - СлучайнаяСоставляющая;
		
		ВосстановленнаяСтрока = ВосстановленнаяСтрока + Символ(КодСимволаИсходнойСтроки);
		
	КонецЦикла;
	
	Возврат ВосстановленнаяСтрока;
	
КонецФункции

Функция ПолучитьМаксимальныйКодСимволаСтроки(СтрокаАнализа)

	ДлинаСтрокиАнализа = СтрДлина(СтрокаАнализа);

	МаксимальныйКодСимвола = 0;

	Для Счетчик = 1 По ДлинаСтрокиАнализа Цикл

		КодТекущегоСимвола = КодСимвола(СтрокаАнализа, Счетчик);

		Если КодТекущегоСимвола > МаксимальныйКодСимвола Тогда

			МаксимальныйКодСимвола = КодТекущегоСимвола;

		КонецЕсли;

	КонецЦикла;

	Возврат МаксимальныйКодСимвола;

КонецФункции

#КонецОбласти

//	LNK 14.07.2021 06:01:51
Функция ЗащищенныеПраваПользователей(ВернутьСоответствие = Ложь)	Экспорт

	СписокОригинал = Новый Массив;
	СписокОригинал.Добавить(ПланыВидовХарактеристик.ПраваПользователей.АдминистраторПолномочный);
	СписокОригинал.Добавить(ПланыВидовХарактеристик.ПраваПользователей.АдминистраторПодарочныхСертификатов);
	СписокОригинал.Добавить(ПланыВидовХарактеристик.ПраваПользователей.РазрешитьИзменениеПрефиксаКартыДисконта);

	Если ВернутьСоответствие = Истина Тогда

		ЗначениеВозврата = Новый Соответствие;

		Для каждого ЭлементСписка Из СписокОригинал Цикл

			ЗначениеВозврата.Вставить(ЭлементСписка, Истина);

		КонецЦикла;

	Иначе

		ЗначениеВозврата = СписокОригинал;

	КонецЕсли;

	Возврат ЗначениеВозврата;

КонецФункции






